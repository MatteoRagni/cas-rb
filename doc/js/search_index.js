var search_data = {"index":{"searchIndex":["cas","abs","acos","asin","atan","binaryop","boxcondition","boxconditionclosed","boxconditionlowerclosed","boxconditionopen","boxconditionupperclosed","caserror","condition","constant","math","cos","diff","div","e_constant","equal","exp","function","greater","greaterequal","help","infinity_constant","invert","ln","minus_one_constant","math","max","min","minmax","neg_infinity_constant","naryop","one_constant","op","pi_constant","piecewise","pow","prod","sin","smaller","smallerequal","sqrt","sum","two_constant","tan","variable","zero_constant","fixnum","float","!=()","*()","*()","*()","**()","**()","**()","+()","+()","+()","-()","-()","-()","-@()","/()","/()","/()","==()","==()","==()","==()","==()","==()","==()","==()","==()","==()","[]()","[]()","abs()","acos()","arccos()","arcsin()","arctan()","args()","args()","args()","args()","args()","args()","args()","args()","as_proc()","asin()","assert()","assert_name()","atan()","box()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","const()","cos()","declare()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","equal()","equal()","exist?()","exist?()","exp()","export_dot()","greater()","greater()","greater_equal()","greater_equal()","in()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","init_simplify_dict()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","invert()","limit()","list()","list()","ln()","log()","max()","min()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","numeric_to_const()","overloaded_div()","overloaded_div()","overloaded_minus()","overloaded_minus()","overloaded_mul()","overloaded_mul()","overloaded_plus()","overloaded_plus()","overloaded_pow()","overloaded_pow()","pow()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify_dict()","simplify_dictionary()","sin()","size()","size()","smaller()","smaller()","smaller_equal()","smaller_equal()","sqrt()","subs()","subs()","subs()","subs()","subs()","subs()","subs()","subs()","subs_lhs()","subs_rhs()","tan()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_dot()","to_dot()","to_dot()","to_latex()","to_latex()","to_latex()","to_latex()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","vars()","readme"],"longSearchIndex":["cas","cas::abs","cas::acos","cas::asin","cas::atan","cas::binaryop","cas::boxcondition","cas::boxconditionclosed","cas::boxconditionlowerclosed","cas::boxconditionopen","cas::boxconditionupperclosed","cas::caserror","cas::condition","cas::constant","cas::constant::math","cas::cos","cas::diff","cas::div","cas::e_constant","cas::equal","cas::exp","cas::function","cas::greater","cas::greaterequal","cas::help","cas::infinity_constant","cas::invert","cas::ln","cas::minus_one_constant","cas::math","cas::max","cas::min","cas::minmax","cas::neg_infinity_constant","cas::naryop","cas::one_constant","cas::op","cas::pi_constant","cas::piecewise","cas::pow","cas::prod","cas::sin","cas::smaller","cas::smallerequal","cas::sqrt","cas::sum","cas::two_constant","cas::tan","cas::variable","cas::zero_constant","fixnum","float","cas::op#!=()","cas::op#*()","fixnum#*()","float#*()","cas::op#**()","fixnum#**()","float#**()","cas::op#+()","fixnum#+()","float#+()","cas::op#-()","fixnum#-()","float#-()","cas::op#-@()","cas::op#/()","fixnum#/()","float#/()","cas::binaryop#==()","cas::boxcondition#==()","cas::condition#==()","cas::constant#==()","cas::equal#==()","cas::function#==()","cas::naryop#==()","cas::op#==()","cas::piecewise#==()","cas::variable#==()","cas::function::[]()","cas::variable::[]()","cas::abs()","cas::acos()","cas::arccos()","cas::arcsin()","cas::arctan()","cas::binaryop#args()","cas::boxcondition#args()","cas::condition#args()","cas::constant#args()","cas::function#args()","cas::naryop#args()","cas::op#args()","cas::variable#args()","cas::op#as_proc()","cas::asin()","cas::help::assert()","cas::help::assert_name()","cas::atan()","cas::box()","cas::abs#call()","cas::acos#call()","cas::asin#call()","cas::atan#call()","cas::binaryop#call()","cas::boxcondition#call()","cas::boxconditionclosed#call()","cas::boxconditionlowerclosed#call()","cas::boxconditionopen#call()","cas::boxconditionupperclosed#call()","cas::condition#call()","cas::constant#call()","cas::cos#call()","cas::diff#call()","cas::div#call()","cas::equal#call()","cas::exp#call()","cas::function#call()","cas::greater#call()","cas::greaterequal#call()","cas::invert#call()","cas::ln#call()","cas::naryop#call()","cas::op#call()","cas::piecewise#call()","cas::pow#call()","cas::prod#call()","cas::sin#call()","cas::smaller#call()","cas::smallerequal#call()","cas::sqrt#call()","cas::sum#call()","cas::tan#call()","cas::variable#call()","cas::const()","cas::cos()","cas::declare()","cas::binaryop#depend?()","cas::boxcondition#depend?()","cas::condition#depend?()","cas::constant#depend?()","cas::naryop#depend?()","cas::op#depend?()","cas::variable#depend?()","cas::abs#diff()","cas::acos#diff()","cas::asin#diff()","cas::atan#diff()","cas::binaryop#diff()","cas::boxcondition#diff()","cas::condition#diff()","cas::constant#diff()","cas::cos#diff()","cas::diff#diff()","cas::div#diff()","cas::exp#diff()","cas::function#diff()","cas::invert#diff()","cas::ln#diff()","cas::naryop#diff()","cas::op#diff()","cas::piecewise#diff()","cas::pow#diff()","cas::prod#diff()","cas::sin#diff()","cas::sqrt#diff()","cas::sum#diff()","cas::tan#diff()","cas::variable#diff()","cas::binaryop#dot_graph()","cas::condition#dot_graph()","cas::naryop#dot_graph()","cas::op#dot_graph()","cas::piecewise#dot_graph()","cas::equal()","cas::op#equal()","cas::function::exist?()","cas::variable::exist?()","cas::exp()","cas::export_dot()","cas::greater()","cas::op#greater()","cas::greater_equal()","cas::op#greater_equal()","cas::in()","cas::abs::init_simplify_dict()","cas::acos::init_simplify_dict()","cas::asin::init_simplify_dict()","cas::atan::init_simplify_dict()","cas::cos::init_simplify_dict()","cas::exp::init_simplify_dict()","cas::invert::init_simplify_dict()","cas::ln::init_simplify_dict()","cas::op::init_simplify_dict()","cas::sin::init_simplify_dict()","cas::tan::init_simplify_dict()","cas::binaryop#inspect()","cas::boxcondition#inspect()","cas::condition#inspect()","cas::constant#inspect()","cas::function#inspect()","cas::naryop#inspect()","cas::op#inspect()","cas::variable#inspect()","cas::invert()","cas::op#limit()","cas::function::list()","cas::variable::list()","cas::ln()","cas::log()","cas::max()","cas::min()","cas::binaryop::new()","cas::boxcondition::new()","cas::condition::new()","cas::constant::new()","cas::e_constant::new()","cas::function::new()","cas::function::new()","cas::infinity_constant::new()","cas::minus_one_constant::new()","cas::max::new()","cas::min::new()","cas::neg_infinity_constant::new()","cas::naryop::new()","cas::one_constant::new()","cas::op::new()","cas::pi_constant::new()","cas::piecewise::new()","cas::two_constant::new()","cas::variable::new()","cas::variable::new()","cas::zero_constant::new()","cas::op::numeric_to_const()","fixnum#overloaded_div()","float#overloaded_div()","fixnum#overloaded_minus()","float#overloaded_minus()","fixnum#overloaded_mul()","float#overloaded_mul()","fixnum#overloaded_plus()","float#overloaded_plus()","fixnum#overloaded_pow()","float#overloaded_pow()","cas::pow()","cas::boxcondition#representative()","cas::boxconditionclosed#representative()","cas::boxconditionlowerclosed#representative()","cas::boxconditionopen#representative()","cas::boxconditionupperclosed#representative()","cas::condition#representative()","cas::equal#representative()","cas::greater#representative()","cas::greaterequal#representative()","cas::smaller#representative()","cas::smallerequal#representative()","cas::abs#simplify()","cas::acos#simplify()","cas::asin#simplify()","cas::atan#simplify()","cas::binaryop#simplify()","cas::boxcondition#simplify()","cas::condition#simplify()","cas::constant#simplify()","cas::cos#simplify()","cas::diff#simplify()","cas::div#simplify()","cas::exp#simplify()","cas::function#simplify()","cas::invert#simplify()","cas::ln#simplify()","cas::naryop#simplify()","cas::op#simplify()","cas::pow#simplify()","cas::prod#simplify()","cas::sin#simplify()","cas::sqrt#simplify()","cas::sum#simplify()","cas::tan#simplify()","cas::variable#simplify()","cas::op::simplify_dict()","cas::op#simplify_dictionary()","cas::sin()","cas::function::size()","cas::variable::size()","cas::smaller()","cas::op#smaller()","cas::smaller_equal()","cas::op#smaller_equal()","cas::sqrt()","cas::binaryop#subs()","cas::boxcondition#subs()","cas::condition#subs()","cas::constant#subs()","cas::function#subs()","cas::naryop#subs()","cas::op#subs()","cas::variable#subs()","cas::binaryop#subs_lhs()","cas::binaryop#subs_rhs()","cas::tan()","cas::abs#to_code()","cas::acos#to_code()","cas::asin#to_code()","cas::atan#to_code()","cas::binaryop#to_code()","cas::boxcondition#to_code()","cas::condition#to_code()","cas::cos#to_code()","cas::diff#to_code()","cas::div#to_code()","cas::exp#to_code()","cas::function#to_code()","cas::invert#to_code()","cas::ln#to_code()","cas::naryop#to_code()","cas::op#to_code()","cas::piecewise#to_code()","cas::pow#to_code()","cas::prod#to_code()","cas::sin#to_code()","cas::sqrt#to_code()","cas::sum#to_code()","cas::tan#to_code()","cas::variable#to_code()","cas::to_dot()","cas::constant#to_dot()","cas::variable#to_dot()","cas::exp#to_latex()","cas::ln#to_latex()","cas::minmax#to_latex()","cas::piecewise#to_latex()","cas::abs#to_s()","cas::acos#to_s()","cas::asin#to_s()","cas::atan#to_s()","cas::binaryop#to_s()","cas::boxcondition#to_s()","cas::condition#to_s()","cas::constant#to_s()","cas::cos#to_s()","cas::diff#to_s()","cas::div#to_s()","cas::e_constant#to_s()","cas::exp#to_s()","cas::function#to_s()","cas::infinity_constant#to_s()","cas::invert#to_s()","cas::ln#to_s()","cas::minus_one_constant#to_s()","cas::minmax#to_s()","cas::neg_infinity_constant#to_s()","cas::naryop#to_s()","cas::one_constant#to_s()","cas::op#to_s()","cas::pi_constant#to_s()","cas::piecewise#to_s()","cas::pow#to_s()","cas::prod#to_s()","cas::sin#to_s()","cas::sqrt#to_s()","cas::sum#to_s()","cas::two_constant#to_s()","cas::tan#to_s()","cas::variable#to_s()","cas::zero_constant#to_s()","cas::vars()",""],"info":[["CAS","","CAS.html","","<p>&lt;b&gt;_ _ _ &lt;b&gt;_ _ _\n / <strong>|_ _ __ _ _ | |_\n<em>(</em>)</strong>_ | _ \\ |_ _ __ <em>(</em>)_ _\n| (_ | &#39;&lt;em&gt;/\n&lt;em&gt; ...\n"],["CAS::Abs","","CAS/Abs.html","","<p>Absolute value of a function. It can be also implemented as a Piecewise\nfunction.\n"],["CAS::Acos","","CAS/Acos.html","","<p>Representation for the <code>arccos(x)</code> function. It is\nimplemented\nas a <code>CAS::Op</code>. It is the inverse of the  ...\n"],["CAS::Asin","","CAS/Asin.html","","<p>Representation for the <code>arcsin(x)</code> function. It is\nimplemented\nas a <code>CAS::Op</code>. It is the inverse of the  ...\n"],["CAS::Atan","","CAS/Atan.html","","<p>Representation for the <code>arctan(x)</code> function. It is\nimplemented\nas a <code>CAS::Op</code>. It is the inverse of the  ...\n"],["CAS::BinaryOp","","CAS/BinaryOp.html","","<p>Binary operator\n"],["CAS::BoxCondition","","CAS/BoxCondition.html","","<p>BoxCondition class constructs a condition of the type:\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">L</span> <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-identifier\">f</span>(<span class=\"ruby-identifier\">x</span>) <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-constant\">U</span>\n</pre>\n<p>and this is a metaclass for different …\n"],["CAS::BoxConditionClosed","","CAS/BoxConditionClosed.html","","<p>Implements the box condition with both bounds closed\n\n<pre>a ≤ f(x) ≤ b</pre>\n"],["CAS::BoxConditionLowerClosed","","CAS/BoxConditionLowerClosed.html","","<p>Implements the box condition with lower bound closed and upper open\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> <span class=\"ruby-identifier\">≤</span> <span class=\"ruby-identifier\">f</span>(<span class=\"ruby-identifier\">x</span>) <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["CAS::BoxConditionOpen","","CAS/BoxConditionOpen.html","","<p>Implements the box condition with both bounds are open\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span> <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-identifier\">f</span>(<span class=\"ruby-identifier\">x</span>) <span class=\"ruby-operator\">&lt;</span> <span class=\"ruby-identifier\">b</span>\n</pre>\n"],["CAS::BoxConditionUpperClosed","","CAS/BoxConditionUpperClosed.html","","<p>Implements the box condition with lower bound open and upper closed\n\n<pre>a &lt; f(x) ≤ b</pre>\n"],["CAS::CASError","","CAS/CASError.html","",""],["CAS::Condition","","CAS/Condition.html","","<p>Condition class is a pseudo-class for all the other kind of conditions:\n<p>Equal\n<p>Greater\n"],["CAS::Constant","","CAS/Constant.html","",""],["CAS::Constant::Math","","CAS/Constant/Math.html","",""],["CAS::Cos","","CAS/Cos.html","","<p>Representation for the <code>cos(x)</code> function. It is implemented\nas a\n<code>CAS::Op</code>.\n"],["CAS::Diff","","CAS/Diff.html","","<p><strong>Difference basic operation</strong>. It&#39;s a binary operation.\nThis cannot\nbe implemented as a n-ary op, thus ...\n"],["CAS::Div","","CAS/Div.html","","<p>Division between two functions. A function divided by zero it is\nconsidered\nas an Infinity.\n"],["CAS::E_CONSTANT","","CAS/E_CONSTANT.html","","<p>Class that represents the constant E (e)\n"],["CAS::Equal","","CAS/Equal.html","","<p>This class is a Condition for two equal function\n"],["CAS::Exp","","CAS/Exp.html","","<p>Representation for the <code>e^x</code> function. It is implemented\nas a\n<code>CAS::Op</code>\n"],["CAS::Function","","CAS/Function.html","","<p>Unknown function class. Will allow to make symbolic differentiation and\nso\non.\n"],["CAS::Greater","","CAS/Greater.html","","<p>This class is a Condition for right smaller function\n"],["CAS::GreaterEqual","","CAS/GreaterEqual.html","","<p>This class is a condition for right smaller or equal function\n"],["CAS::Help","","CAS/Help.html","","<p>Support functions are in this separate Helper class\n"],["CAS::INFINITY_CONSTANT","","CAS/INFINITY_CONSTANT.html","","<p>Class that represents the constant Infinity (∞)\n"],["CAS::Invert","","CAS/Invert.html","","<p>Invert is the same as multiply by <code>-1</code> a\nfunction.\n<code>Invert(x)</code> is equal to <code>-x</code>\n"],["CAS::Ln","","CAS/Ln.html","","<p>Representation for the <code>log(x)</code> function. It is implemented\nas a\n<code>CAS::Op</code>\n"],["CAS::MINUS_ONE_CONSTANT","","CAS/MINUS_ONE_CONSTANT.html","","<p>Class that represents the constant Minus One (-1)\n"],["CAS::Math","","CAS/Math.html","",""],["CAS::Max","","CAS/Max.html","","<p>Max class represent a piecewise in which the condition is <code>f(x) ≥\ng(x)</code>. Derivate a <code>CAS::Max</code>\nwill return ...\n"],["CAS::Min","","CAS/Min.html","","<p>Min class represent a piecewise in which the condition is <code>f(x) ≤\ng(x)</code>. Derivate a <code>CAS::Min</code>\nwill return ...\n"],["CAS::MinMax","","CAS/MinMax.html","","<p>Class MinMax is an intermediate class for Min and Max functions. It\ncontains shared code\nand methods ...\n"],["CAS::NEG_INFINITY_CONSTANT","","CAS/NEG_INFINITY_CONSTANT.html","","<p>Class that represents the constant Negative Infinity (-∞)\n"],["CAS::NaryOp","","CAS/NaryOp.html","","<p>This is an attempt to build some sort of node in the graph that\nhas\narbitrary number of childs node. ...\n"],["CAS::ONE_CONSTANT","","CAS/ONE_CONSTANT.html","","<p>Class that represents the constant One (1)\n"],["CAS::Op","","CAS/Op.html","","<p>&lt;b&gt;_\n / _ \\ _ &lt;em&gt;_\n| (&lt;/em&gt;) | &#39;_ \\\n _&lt;/b&gt;/|\n._&lt;em&gt;/\n |&lt;/em&gt;| ...\n"],["CAS::PI_CONSTANT","","CAS/PI_CONSTANT.html","","<p>Class that represents the constant Pi (π)\n"],["CAS::Piecewise","","CAS/Piecewise.html","","<p>Piecewise function. The function returns when called a result\nthat dependes\nupon the evaluation of a ...\n"],["CAS::Pow","","CAS/Pow.html","","<p>Power function.\n"],["CAS::Prod","","CAS/Prod.html","","<p>Product class. Performs the product between two elements.\nThis class will\nbe soon modified as an n-ary ...\n"],["CAS::Sin","","CAS/Sin.html","","<p>Representation for the <code>sin(x)</code> function. It is implemented\nas a\n<code>CAS::Op</code>\n"],["CAS::Smaller","","CAS/Smaller.html","","<p>This class is a Condition for left smaller function\n"],["CAS::SmallerEqual","","CAS/SmallerEqual.html","","<p>This class is a Condition for left smaller or equal function\n"],["CAS::Sqrt","","CAS/Sqrt.html","","<p>Square Root of a function. Even if it can be implemented as a power\nfunction,\nit is a separated class. ...\n"],["CAS::Sum","","CAS/Sum.html","","<p><strong>Sum basic operation</strong>. As for now it is implemented as a\nsimple\nbinary operation. It will be implemented ...\n"],["CAS::TWO_CONSTANT","","CAS/TWO_CONSTANT.html","","<p>Class that represents the constant Two (2)\n"],["CAS::Tan","","CAS/Tan.html","","<p>Representation for the <code>tan(x)</code> function. It is implemented\nas a\n<code>CAS::Op</code>.\n"],["CAS::Variable","","CAS/Variable.html","","<p>Container for a variable. It can be resolved in a numerical value.\nIt can\nalso be used for derivatives. ...\n"],["CAS::ZERO_CONSTANT","","CAS/ZERO_CONSTANT.html","","<p>Class that represents the constant Zero (0)\n"],["Fixnum","","Fixnum.html","","<p>Overloading operators for Fixnum. Operations that are\noveloaded are:\n<p><code>overloaded_plus</code> for <code>+</code>\n<p><code>overloaded_minus</code> …\n"],["Float","","Float.html","","<p>Overloading operators for Float. Operations that are\noveloaded are:\n<p><code>overloaded_plus</code> for <code>+</code>\n<p><code>overloaded_minus</code> …\n"],["!=","CAS::Op","CAS/Op.html#method-i-21-3D","(op)","<p>Disequality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on ...\n"],["*","CAS::Op","CAS/Op.html#method-i-2A","(op)","<p>Returns a product of two <code>CAS::Op</code>s\n<p><strong>argument</strong>: <code>CAS::Op</code> tree\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n"],["*","Fixnum","Fixnum.html#method-i-2A","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["*","Float","Float.html#method-i-2A","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["**","CAS::Op","CAS/Op.html#method-i-2A-2A","(op)","<p>Returns the power of two <code>CAS::Op</code>s\n<p><strong>argument</strong>: <code>CAS::Op</code> tree\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n"],["**","Fixnum","Fixnum.html#method-i-2A-2A","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["**","Float","Float.html#method-i-2A-2A","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["+","CAS::Op","CAS/Op.html#method-i-2B","(op)","<p>Returns a sum of two <code>CAS::Op</code>s\n<p><strong>argument</strong>: <code>CAS::Op</code> tree\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n"],["+","Fixnum","Fixnum.html#method-i-2B","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation.\nIf\n"],["+","Float","Float.html#method-i-2B","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation.\nIf\n"],["-","CAS::Op","CAS/Op.html#method-i-2D","(op)","<p>Returns a difference of two <code>CAS::Op</code>s\n<p><strong>argument</strong>: <code>CAS::Op</code> tree\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n"],["-","Fixnum","Fixnum.html#method-i-2D","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["-","Float","Float.html#method-i-2D","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["-@","CAS::Op","CAS/Op.html#method-i-2D-40","()","<p>Unary operator for inversion of a <code>CAS::Op</code>\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n\n"],["/","CAS::Op","CAS/Op.html#method-i-2F","(op)","<p>Returns a division of two <code>CAS::Op</code>s\n<p><strong>argument</strong>: <code>CAS::Op</code> tree\n<p><strong>returns</strong>: <code>CAS::Op</code> new object\n"],["/","Fixnum","Fixnum.html#method-i-2F","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["/","Float","Float.html#method-i-2F","(a)","<p>If <code>a</code> is a <code>CAS::Op</code> transform self in a\n<code>CAS::Const</code>\nand return a symbolic operation\n"],["==","CAS::BinaryOp","CAS/BinaryOp.html#method-i-3D-3D","(op)","<p>Comparison with other <code>CAS::Op</code>. This is <strong>not</strong> a\nmath operation.\n<p><strong>argument</strong>: <code>CAS::Op</code> to be compared against …\n"],["==","CAS::BoxCondition","CAS/BoxCondition.html#method-i-3D-3D","(cond)","<p>Return true if two BoxConditions are equal, false if different\n<p><strong>argument</strong>: <code>CAS::Op</code> operator to check against …\n"],["==","CAS::Condition","CAS/Condition.html#method-i-3D-3D","(op)","<p>Return true if two functions are equal, false if different\n<p><strong>argument</strong>: <code>CAS::Op</code> operator to check against …\n"],["==","CAS::Constant","CAS/Constant.html#method-i-3D-3D","(op)","<p>Check if a constant is equal to another <code>CAS::Op</code> object\n<p><strong>argument</strong>: <code>CAs::Op</code>\n<p><strong>returns</strong>: <code>TrueClass</code> or <code>FalseClass</code>\n…\n"],["==","CAS::Equal","CAS/Equal.html#method-i-3D-3D","(op)","<p>Return true if two functions are equal, false if different\n<p><strong>argument</strong>: <code>CAS::Op</code> operator to check against …\n"],["==","CAS::Function","CAS/Function.html#method-i-3D-3D","(op)","<p>Checks if two functions can be considered equal (same name, same args)\n<p><strong>requires</strong>: another op to be checked …\n"],["==","CAS::NaryOp","CAS/NaryOp.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on the ...\n"],["==","CAS::Op","CAS/Op.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on the ...\n"],["==","CAS::Piecewise","CAS/Piecewise.html#method-i-3D-3D","(op)","<p>Checks if two <code>CAS::Piecewise</code> are equal. Checks equality on all\nfunctions+\nand conditions\n<p><strong>argument</strong>: <code>CAS::Op</code> …\n"],["==","CAS::Variable","CAS/Variable.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on the ...\n"],["[]","CAS::Function","CAS/Function.html#method-c-5B-5D","(s)","<p>Returns a function given its name\n<p><strong>argument</strong>: <code>Object</code> name of the function\n<p><strong>returns</strong>: <code>CAS::Function</code> instance …\n"],["[]","CAS::Variable","CAS/Variable.html#method-c-5B-5D","(s)","<p>Returns a variable given its name\n<p><strong>argument</strong>: <code>Object</code> name of the variable\n<p><strong>returns</strong>: <code>CAS::Variable</code> instance …\n"],["abs","CAS","CAS.html#method-c-abs","(x)","<p>Shortcut for <code>CAs::Abs</code> initializer\n<p><strong>argument</strong>: <code>CAs::Op</code> argument of absolute value\n<p><strong>returns</strong>: <code>CAS::Abs</code> new instance …\n"],["acos","CAS","CAS.html#method-c-acos","(x)","<p>Shortcut for <code>CAS::Acos#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Acos</code> operation\n"],["arccos","CAS","CAS.html#method-c-arccos","(x)",""],["arcsin","CAS","CAS.html#method-c-arcsin","(x)",""],["arctan","CAS","CAS.html#method-c-arctan","(x)",""],["args","CAS::BinaryOp","CAS/BinaryOp.html#method-i-args","()","<p>Returns an array of all the variables that are in the graph\n<p><strong>returns</strong>: <code>Array</code> of <code>CAS::Variable</code>s\n\n"],["args","CAS::BoxCondition","CAS/BoxCondition.html#method-i-args","()","<p>Returns an array of variables of the central function\n<p><strong>returns</strong>: <code>Array</code> of <code>CAS::Variable</code>\n\n"],["args","CAS::Condition","CAS/Condition.html#method-i-args","()","<p>Returns an array of variables of the two functions in the condition\n<p><strong>returns</strong>: <code>Array</code> of <code>CAS::Variable</code>\n\n"],["args","CAS::Constant","CAS/Constant.html#method-i-args","()","<p>Args of a constant is an empty <code>Array</code>\n<p><strong>returns</strong>: <code>Array</code> empty\n\n"],["args","CAS::Function","CAS/Function.html#method-i-args","()","<p>Returns an array containing <code>CAS::Variable</code>s argument of the\nfunction\n<p><strong>returns</strong>: <code>Array</code> containing\n<code>CAs:;Variable</code> …\n\n"],["args","CAS::NaryOp","CAS/NaryOp.html#method-i-args","()","<p>Returns a list of all <code>CAS::Variable</code>s of the current tree\n<p><strong>returns</strong>: <code>Array</code> of <code>CAS::Variable</code>s\n\n"],["args","CAS::Op","CAS/Op.html#method-i-args","()","<p>Returns a list of all <code>CAS::Variable</code>s of the current tree\n<p><strong>returns</strong>: <code>Array</code> of <code>CAS::Variable</code>s\n\n"],["args","CAS::Variable","CAS/Variable.html#method-i-args","()","<p>Returns an array containing <code>self</code>\n<p><strong>returns</strong>: <code>Array</code> containing <code>self</code>\n\n"],["as_proc","CAS::Op","CAS/Op.html#method-i-as_proc","(bind=nil)","<p>Evaluates the proc against a given context. It is like having a\nsnapshot of\nthe tree transformed in a ...\n"],["asin","CAS","CAS.html#method-c-asin","(x)","<p>Shortcuts for <code>CAS::Asin#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Asin</code> operation\n"],["assert","CAS::Help","CAS/Help.html#method-c-assert","(obj, type)","<p>Check input <code>obj.class</code> against a <code>type</code> class\nraises\nan <code>ArgumentError</code> if check fails\n<p><strong>argument</strong>: object to …\n"],["assert_name","CAS::Help","CAS/Help.html#method-c-assert_name","(obj)","<p>Check if input object is feasible to be a name of a\n<code>CAS::Variable</code> or a <code>CAS::Function</code>\nraise an\n<code>ArgumentError</code> ...\n"],["atan","CAS","CAS.html#method-c-atan","(x)","<p>Shortcut for <code>CAS::Atan#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Atan</code> operation\n"],["box","CAS","CAS.html#method-c-box","(x, a, b, type=:closed)","<p>Shortcut for creating a new box condition. It requires four arguments:\n<p><strong>argument</strong>: <code>CAS::Op</code> function for …\n"],["call","CAS::Abs","CAS/Abs.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Acos","CAS/Acos.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Asin","CAS/Asin.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Atan","CAS/Atan.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::BinaryOp","CAS/BinaryOp.html#method-i-call","(_fd)","<p>Same <code>CAS::Op#call</code>\n<p><strong>argument</strong>: <code>Hash</code> of values\n<p><strong>returns</strong>: <code>Numeric</code> for result\n"],["call","CAS::BoxCondition","CAS/BoxCondition.html#method-i-call","(_fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::BoxConditionClosed","CAS/BoxConditionClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary\n<p><strong>returns</strong> …\n"],["call","CAS::BoxConditionLowerClosed","CAS/BoxConditionLowerClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary\n<p><strong>returns</strong> …\n"],["call","CAS::BoxConditionOpen","CAS/BoxConditionOpen.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary\n<p><strong>returns</strong> …\n"],["call","CAS::BoxConditionUpperClosed","CAS/BoxConditionUpperClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary\n<p><strong>returns</strong> …\n"],["call","CAS::Condition","CAS/Condition.html#method-i-call","(_fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::Constant","CAS/Constant.html#method-i-call","(_f)","<p>Calling a constant will return the value of the constant\nitself.\n<p><strong>argument</strong>: Unused argument\n<p><strong>returns</strong>: <code>Numeric</code> …\n"],["call","CAS::Cos","CAS/Cos.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Diff","CAS/Diff.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Div","CAS/Div.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Equal","CAS/Equal.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::Exp","CAS/Exp.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Function","CAS/Function.html#method-i-call","(_v)","<p>Trying to call a <code>CAS::Function</code> will always return a\n<code>CAS::Error</code>\n<p><strong>raises</strong>: <code>CAS::CASError</code>\n\n"],["call","CAS::Greater","CAS/Greater.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::GreaterEqual","CAS/GreaterEqual.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::Invert","CAS/Invert.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Ln","CAS/Ln.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::NaryOp","CAS/NaryOp.html#method-i-call","(fd)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Op","CAS/Op.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Piecewise","CAS/Piecewise.html#method-i-call","(fd)","<p>Executes the condition. If it is <code>true</code> it returns the first\nfunction,\nelse it returns the value of the ...\n"],["call","CAS::Pow","CAS/Pow.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Prod","CAS/Prod.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Sin","CAS/Sin.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Smaller","CAS/Smaller.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::SmallerEqual","CAS/SmallerEqual.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the\nrelation\n<p><strong>argument</strong>: <code>Hash</code> with feed dictionary …\n"],["call","CAS::Sqrt","CAS/Sqrt.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Sum","CAS/Sum.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Tan","CAS/Tan.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Variable","CAS/Variable.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> (depends upon promotions).\nAs\ninput, ...\n"],["const","CAS","CAS.html#method-c-const","(*val)","<p>Allows to define a series of new constants.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>, <span class=\"ruby-identifier\">b</span> = <span class=\"ruby-constant\">CAS</span><span class=\"ruby-operator\">::</span><span class=\"ruby-identifier\">const</span> <span class=\"ruby-value\">1.0</span>, <span class=\"ruby-value\">100</span>\n</pre>\n<p><strong>argument</strong>: <code>Array</code> of Numeric\n"],["cos","CAS","CAS.html#method-c-cos","(x)","<p>Shortcut for <code>CAS::Cos#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Cos</code> operation\n"],["declare","CAS","CAS.html#method-c-declare","(name, *xs)","<p>This shortcut allows to declare a new function\n<p><strong>requires</strong>: <code>String</code> or <code>Symbol</code> that\nis the name of the function …\n"],["depend?","CAS::BinaryOp","CAS/BinaryOp.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a\n<code>CAS::Variable</code>\nand it is one of the recursve method ...\n"],["depend?","CAS::BoxCondition","CAS/BoxCondition.html#method-i-depend-3F","(v)","<p>Returns true if one the central function depends upon the expression\nincluded\n<p><strong>argument</strong>: <code>CAS::Op</code> operator …\n"],["depend?","CAS::Condition","CAS/Condition.html#method-i-depend-3F","(v)","<p>Returns true if one of the two functions depends upon the expression\nincluded\n<p><strong>argument</strong>: <code>CAS::Op</code> operator …\n"],["depend?","CAS::Constant","CAS/Constant.html#method-i-depend-3F","(_v)","<p>There is no dependency in a constant, thus this method will\nalways return\nfalse\n<p><strong>argument</strong>: Unused argument …\n"],["depend?","CAS::NaryOp","CAS/NaryOp.html#method-i-depend-3F","(v)","<p>Returns the dependencies of the operation. Require a\n<code>CAS::Variable</code>\nand it is one of the recursive method ...\n"],["depend?","CAS::Op","CAS/Op.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a\n<code>CAS::Variable</code>\nand it is one of the recursve method ...\n"],["depend?","CAS::Variable","CAS/Variable.html#method-i-depend-3F","(v)","<p>Returns <code>TrueClass</code> if argument of the function is equal\nto\n<code>self</code>\n<p><strong>argument</strong>: <code>CAS::Op</code>\n<p><strong>returns</strong>: <code>TrueClass</code> or …\n"],["diff","CAS::Abs","CAS/Abs.html#method-i-diff","(v)","<p>Performs the absolute value of a <code>CAS::Op</code>\n\n<pre>d\n---- |f(x)| = f&#39;(x) * (f(x) / |f(x)|)\n dx</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> …\n"],["diff","CAS::Acos","CAS/Acos.html#method-i-diff","(v)",""],["diff","CAS::Asin","CAS/Asin.html#method-i-diff","(v)","<p>Return the derivative of the <code>arcsin(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code>\n<p><strong>argument</strong> …\n"],["diff","CAS::Atan","CAS/Atan.html#method-i-diff","(v)","<p>Return the derivative of the <code>arctan(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because ...\n"],["diff","CAS::BinaryOp","CAS/BinaryOp.html#method-i-diff","(v)","<p>This method returns an array with the derivatives of the two branches\nof\nthe node. This method is usually ...\n"],["diff","CAS::BoxCondition","CAS/BoxCondition.html#method-i-diff","(v)","<p>Performs the derivative of the box condition. The derivative of\na box\ncondition is a <code>CAS::Equal</code> object ...\n"],["diff","CAS::Condition","CAS/Condition.html#method-i-diff","(v)","<p>Performs the derivative of the two elements:\n\n<pre>d\n-- [f(x) &gt; g(y)] = f&#39;(x) &gt; g&#39;(x)\ndx</pre>\n<p>since between the two …\n"],["diff","CAS::Constant","CAS/Constant.html#method-i-diff","(_v)","<p>Evaluates the derivative of a constant. The derivative is\nalways a\n<code>CAS::Zero</code>\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n<span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">-</span> <span class=\"ruby-identifier\">c</span> = <span class=\"ruby-value\">0</span>\n<span class=\"ruby-identifier\">dx</span>\n</pre>\n"],["diff","CAS::Cos","CAS/Cos.html#method-i-diff","(v)","<p>Return the derivative of the <code>cos(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because it ...\n"],["diff","CAS::Diff","CAS/Diff.html#method-i-diff","(v)","<p>Performs the difference between two <code>CAS::Op</code>s\n\n<pre>d\n---- (f(x) - g(x)) = f&#39;(x) - g&#39;(x)\n dx</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> …\n"],["diff","CAS::Div","CAS/Div.html#method-i-diff","(v)","<p>Performs the division between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) / g(x)) = (f&#39;(x) * g(x) - f(x) * g&#39;(x))/(g(x)^2) ...</pre>\n"],["diff","CAS::Exp","CAS/Exp.html#method-i-diff","(v)","<p>Return the derivative of the <code>sin(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because it ...\n"],["diff","CAS::Function","CAS/Function.html#method-i-diff","(v)","<p>Performs the derivative with respect to one of the variable. The new\nfunction\nhas a name with respect ...\n"],["diff","CAS::Invert","CAS/Invert.html#method-i-diff","(v)","<p>Performs the inversion of a <code>CAS::Op</code>\n\n<pre>d\n---- (-f(x)) = -f&#39;(x)\n dx</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of derivative …\n"],["diff","CAS::Ln","CAS/Ln.html#method-i-diff","(v)","<p>Return the derivative of the <code>log(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because it ...\n"],["diff","CAS::NaryOp","CAS/NaryOp.html#method-i-diff","(v)","<p>Return a list of derivative using the chain rule. The input is a\noperation:\n\n<pre>f(x) = g(x) + h(x) + l(x) ...</pre>\n"],["diff","CAS::Op","CAS/Op.html#method-i-diff","(v)","<p>Return the derivative of the operation using the chain rule\nThe input is a\n<code>CAS::Op</code> because it can handle ...\n"],["diff","CAS::Piecewise","CAS/Piecewise.html#method-i-diff","(v)","<p>Derivative of a function is performed as derivative of the two internal\nfunctions\nwhile condition is ...\n"],["diff","CAS::Pow","CAS/Pow.html#method-i-diff","(v)","<p>Performs the power between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x)^a) = f(x)^(a - 1) * a * f&#39;(x)\n dx\n\n  d\n---- (a^f(x)) ...</pre>\n"],["diff","CAS::Prod","CAS/Prod.html#method-i-diff","(v)","<p>Performs the product between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) * g(x)) = f&#39;(x) * g(x) + f(x) * g&#39;(x)\n dx</pre>\n<p><strong>argument</strong> …\n"],["diff","CAS::Sin","CAS/Sin.html#method-i-diff","(v)","<p>Return the derivative of the <code>sin(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because it ...\n"],["diff","CAS::Sqrt","CAS/Sqrt.html#method-i-diff","(v)","<p>Performs the square root between two <code>CAS::Op</code>\n\n<pre>d\n---- √f(x) = 1/2 * f&#39;(x) * √f(x)\n dx</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument …\n"],["diff","CAS::Sum","CAS/Sum.html#method-i-diff","(v)","<p>Performs the sum between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) + g(x)) = f&#39;(x) + g&#39;(x)\n dx</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument …\n"],["diff","CAS::Tan","CAS/Tan.html#method-i-diff","(v)","<p>Return the derivative of the <code>tan(x)</code> function using the\nchain\nrule. The input is a <code>CAS::Op</code> because it ...\n"],["diff","CAS::Variable","CAS/Variable.html#method-i-diff","(v)","<p>Returns the derivative of a variable\n\n<pre>dx      dx\n -- = 1; -- = 0\n dx      dy</pre>\n<p><strong>argument</strong>: <code>CAS::Op</code> for the derivative …\n"],["dot_graph","CAS::BinaryOp","CAS/BinaryOp.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p><strong>returns</strong>: <code>String</code> of local Graphiz node\n\n"],["dot_graph","CAS::Condition","CAS/Condition.html#method-i-dot_graph","(node)","<p>Returns the dot graphviz representation of the code\n<p><strong>returns</strong>: <code>String</code>\n\n"],["dot_graph","CAS::NaryOp","CAS/NaryOp.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p><strong>returns</strong>: <code>String</code> of local Graphiz node\n\n"],["dot_graph","CAS::Op","CAS/Op.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p><strong>returns</strong>: <code>String</code> of local Graphiz node\n\n"],["dot_graph","CAS::Piecewise","CAS/Piecewise.html#method-i-dot_graph","()","<p>Convert piecewise function into a dot graphviz representation\n<p><strong>returns</strong>: <code>String</code>\n\n"],["equal","CAS","CAS.html#method-c-equal","(x, y)","<p>Shortcut creates a <code>CAS::Equal</code> object\n"],["equal","CAS::Op","CAS/Op.html#method-i-equal","(v)","<p>Shortcut for creating equality condition.\n<p><strong>argument</strong>: <code>CAS::Op</code> ther element of the\ncondition\n<p><strong>returns</strong>: <code>CAS::Equal</code> …\n"],["exist?","CAS::Function","CAS/Function.html#method-c-exist-3F","(name)","<p>Return <code>true</code> if a function was already defined\n<p><strong>argument</strong>: name of the function to be checked\n\n"],["exist?","CAS::Variable","CAS/Variable.html#method-c-exist-3F","(name)","<p>Returns <code>true</code> if a variable already exists\n<p><strong>argument</strong>: <code>Object</code> that represent the variable\n<p><strong>returns</strong>: <code>TrueClass</code> …\n"],["exp","CAS","CAS.html#method-c-exp","(x)","<p>Shortcut for <code>CAS::Exp#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Exp</code> operation\n"],["export_dot","CAS","CAS.html#method-c-export_dot","(fl, op)","<p>Export the input <code>CAS::Op</code> graphviz representation to a file.\n<p><strong>argument</strong>: <code>String</code> with filename\n<p><strong>argument</strong>: <code>CAS::Op</code> …\n"],["greater","CAS","CAS.html#method-c-greater","(x, y)","<p>Shortcut creates a <code>CAS::Greater</code> object\n"],["greater","CAS::Op","CAS/Op.html#method-i-greater","(v)","<p>Shortcut for creating greater kind condition.\n<p><strong>argument</strong>: <code>CAS::Op</code> ther element of the\ncondition\n<p><strong>returns</strong>: …\n"],["greater_equal","CAS","CAS.html#method-c-greater_equal","(x, y)","<p>Shortcut creates a <code>CAS::GreaterEqual</code> object\n"],["greater_equal","CAS::Op","CAS/Op.html#method-i-greater_equal","(v)","<p>Shortcut for creating a greater equal kind condition.\n<p><strong>argument</strong>: <code>CAS::Op</code> ther element of the\ncondition …\n"],["in","CAS","CAS.html#method-c-in","(x, a, b, type=:closed)",""],["init_simplify_dict","CAS::Abs","CAS/Abs.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Acos","CAS/Acos.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Asin","CAS/Asin.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Atan","CAS/Atan.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Cos","CAS/Cos.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Exp","CAS/Exp.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Invert","CAS/Invert.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Ln","CAS/Ln.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Op","CAS/Op.html#method-c-init_simplify_dict","()","<p>Initializes the simplification dictionary (one for each class)\n<p><strong>returns</strong>: <code>Hash</code> with simplification dictionary\n…\n\n"],["init_simplify_dict","CAS::Sin","CAS/Sin.html#method-c-init_simplify_dict","()",""],["init_simplify_dict","CAS::Tan","CAS/Tan.html#method-c-init_simplify_dict","()",""],["inspect","CAS::BinaryOp","CAS/BinaryOp.html#method-i-inspect","()","<p>Inspector\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::BoxCondition","CAS/BoxCondition.html#method-i-inspect","()","<p>Inspector for the class. It is class specific\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::Condition","CAS/Condition.html#method-i-inspect","()","<p>Inspector for the class. It is class specific\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::Constant","CAS/Constant.html#method-i-inspect","()","<p>Inspection for <code>CAS::Constant</code> class\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::Function","CAS/Function.html#method-i-inspect","()","<p>Returns the inspect string of the function, that is similar to\n<code>CAS::Function#to_s</code>\n<p><strong>returns</strong>: inspection …\n\n"],["inspect","CAS::NaryOp","CAS/NaryOp.html#method-i-inspect","()","<p>Inspector for the current object\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::Op","CAS/Op.html#method-i-inspect","()","<p>Inspector for the current object\n<p><strong>returns</strong>: <code>String</code>\n\n"],["inspect","CAS::Variable","CAS/Variable.html#method-i-inspect","()","<p>Inspector for the current object\n<p><strong>returns</strong>: <code>String</code>\n\n"],["invert","CAS","CAS.html#method-c-invert","(x)","<p>Shortcut for <code>CAs::Invert</code> initializer\n<p><strong>argument</strong>: <code>CAs::Op</code> argument of the inversion\n<p><strong>returns</strong>: <code>CAS::Invert</code> new …\n"],["limit","CAS::Op","CAS/Op.html#method-i-limit","(a, b, type=:closed)","<p>Shortcut for creating a new box condition. It requires limits and type:\n<p><strong>argument</strong>: <code>CAS::Constant</code> lower …\n"],["list","CAS::Function","CAS/Function.html#method-c-list","()","<p>Return the <code>Hash</code> of the functions\n<p><strong>returns</strong>: <code>Hash</code>\n\n"],["list","CAS::Variable","CAS/Variable.html#method-c-list","()","<p>Returns the <code>Hash</code> that contains all the variable\n<p><strong>returns</strong>: <code>Hash</code>\n\n"],["ln","CAS","CAS.html#method-c-ln","(x)","<p>Shortcut for <code>CAS::Ln#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Ln</code> operation\n"],["log","CAS","CAS.html#method-c-log","(x)",""],["max","CAS","CAS.html#method-c-max","(x, y)","<p>Shortcut for <code>CAS::Max</code> initializer\n<p><strong>argument</strong>: <code>CAS::Op</code> left function\n<p><strong>argument</strong>: <code>CAS::Op</code> right function\n"],["min","CAS","CAS.html#method-c-min","(x, y)","<p>Shortcut for <code>CAS::Min</code> initializer\n<p><strong>argument</strong>: <code>CAS::Op</code> left function\n<p><strong>argument</strong>: <code>CAS::Op</code> right function\n"],["new","CAS::BinaryOp","CAS/BinaryOp.html#method-c-new","(x, y)","<p>The binary operator inherits from the <code>CAS::Op</code>, even\nif it is\ndefined as a node with two possible branches. ...\n"],["new","CAS::BoxCondition","CAS/BoxCondition.html#method-c-new","(x, lower, upper)","<p>Initializes a new box condition. A function is required as central\nterm,\nwhile the second and the third ...\n"],["new","CAS::Condition","CAS/Condition.html#method-c-new","(x, y)","<p>Initializer for a new condition. The condition is implicit in the class,\nthus a\npure <code>CAS::Condition</code> cannot ...\n"],["new","CAS::Constant","CAS/Constant.html#method-c-new","(x)",""],["new","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-c-new","()","<p>Initializer for the E constant\n<p><strong>returns</strong>: <code>CAS::E_CONSTANT</code> new instance\n\n"],["new","CAS::Function","CAS/Function.html#method-c-new","(name, *xs)","<p>Initializes a new function. It requires a name and a series of\narguments\nthat will be the functions on ...\n"],["new","CAS::Function","CAS/Function.html#method-c-new","(name, *xs)","<p>Overrides new method. This will return an existing function if in the\nfunction container\n<p><strong>requires</strong>: <code>String</code> …\n"],["new","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-c-new","()","<p>Initializer for the infinity constant\n<p><strong>returns</strong>: <code>CAS::INFINITY_CONSTANT</code> new instance\n\n"],["new","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-c-new","()","<p>Initializer for the minus one constant\n<p><strong>returns</strong>: <code>CAS::MINUS_ONE_CONSTANT</code> new instance\n\n"],["new","CAS::Max","CAS/Max.html#method-c-new","(x, y)","<p>To initialize <code>CAS::Max</code> only the two functions are necessary.\nThe condition is automatically\ngenerated ...\n"],["new","CAS::Min","CAS/Min.html#method-c-new","(x, y)","<p>To initialize <code>CAS::Min</code> only the two functions are necessary.\nThe condition is automatically\ngenerated ...\n"],["new","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-c-new","()","<p>Initializer for the negative infinity constant\n<p><strong>returns</strong>: <code>CAS::NEG_INFINITY_CONSTANT</code> new\ninstance\n\n"],["new","CAS::NaryOp","CAS/NaryOp.html#method-c-new","(*xs)","<p>Initialize a new empty N-elements operation container. This is\na virtual\nclass, and other must inherit ...\n"],["new","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-c-new","()","<p>Initializer for the one constant\n<p><strong>returns</strong>: <code>CAS::ONE_CONSTANT</code> new instance\n\n"],["new","CAS::Op","CAS/Op.html#method-c-new","(x)","<p>Initialize a new empty operation container. This is a virtual\nclass and the\nother must inherit from this ...\n"],["new","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-c-new","()","<p>Initializer for the pi constant\n<p><strong>returns</strong>: <code>CAS::PI_CONSTANT</code> new instance\n\n"],["new","CAS::Piecewise","CAS/Piecewise.html#method-c-new","(x, y, condition)","<p>Initialize a new piecewise function. It requires first the function\nthat\nreturns when condition is true, ...\n"],["new","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-c-new","()","<p>Initializer for the two constant\n<p><strong>returns</strong>: <code>CAS::TWO_CONSTANT</code> new instance\n\n"],["new","CAS::Variable","CAS/Variable.html#method-c-new","(name)","<p>Variable is a container for an atomic simbol that becomes a number\nwhen\n<code>CAS::Op#call</code> method is used. ...\n"],["new","CAS::Variable","CAS/Variable.html#method-c-new","(name)","<p>Overrides new method. This will return an existing variable if in variable\ncontainer\n<p><strong>requires</strong>: <code>Object</code> …\n"],["new","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-c-new","()","<p>Initializer for the zero constant\n<p><strong>returns</strong>: <code>CAS::ZERO_CONSTANT</code> new instance\n\n"],["numeric_to_const","CAS::Op","CAS/Op.html#method-c-numeric_to_const","(x)",""],["overloaded_div","Fixnum","Fixnum.html#method-i-overloaded_div","(a)",""],["overloaded_div","Float","Float.html#method-i-overloaded_div","(a)",""],["overloaded_minus","Fixnum","Fixnum.html#method-i-overloaded_minus","(a)",""],["overloaded_minus","Float","Float.html#method-i-overloaded_minus","(a)",""],["overloaded_mul","Fixnum","Fixnum.html#method-i-overloaded_mul","(a)",""],["overloaded_mul","Float","Float.html#method-i-overloaded_mul","(a)",""],["overloaded_plus","Fixnum","Fixnum.html#method-i-overloaded_plus","(a)","<p>Setting aliases\n"],["overloaded_plus","Float","Float.html#method-i-overloaded_plus","(a)","<p>Setting aliases\n"],["overloaded_pow","Fixnum","Fixnum.html#method-i-overloaded_pow","(a)",""],["overloaded_pow","Float","Float.html#method-i-overloaded_pow","(a)",""],["pow","CAS","CAS.html#method-c-pow","(x, y)","<p>Shortcut for <code>CAS::Pow</code> initializer\n<p><strong>argument</strong>: <code>CAS::Op</code> base\n<p><strong>argument</strong>: <code>CAS::Op</code> exponent\n"],["representative","CAS::BoxCondition","CAS/BoxCondition.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionClosed","CAS/BoxConditionClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionLowerClosed","CAS/BoxConditionLowerClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionOpen","CAS/BoxConditionOpen.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionUpperClosed","CAS/BoxConditionUpperClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Condition","CAS/Condition.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Equal","CAS/Equal.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Greater","CAS/Greater.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::GreaterEqual","CAS/GreaterEqual.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Smaller","CAS/Smaller.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::SmallerEqual","CAS/SmallerEqual.html#method-i-representative","()","<p>Saves some required elements\n"],["simplify","CAS::Abs","CAS/Abs.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>|-x| = x\n"],["simplify","CAS::Acos","CAS/Acos.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Asin","CAS/Asin.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Atan","CAS/Atan.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::BinaryOp","CAS/BinaryOp.html#method-i-simplify","()","<p>Executes simplifications of the two branches of the graph\n<p><strong>returns</strong>: <code>CAS::BinaryOp</code> as <code>self</code>\n\n"],["simplify","CAS::BoxCondition","CAS/BoxCondition.html#method-i-simplify","()","<p>Simplify left and right term of the operator\n<p><strong>returns</strong>: <code>CAS::BoxCondition</code>\n\n"],["simplify","CAS::Condition","CAS/Condition.html#method-i-simplify","()","<p>Simplify left and right term of the operator\n<p><strong>returns</strong>: <code>CAS::Condition</code>\n\n"],["simplify","CAS::Constant","CAS/Constant.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Cos","CAS/Cos.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Diff","CAS/Diff.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>0 - y = -y\n"],["simplify","CAS::Div","CAS/Div.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>0 / y = 0\n"],["simplify","CAS::Exp","CAS/Exp.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Function","CAS/Function.html#method-i-simplify","()","<p>Simplifications cannot be performed on anonymous function, thus it will\nalways return\nthe <code>self</code> <code>CAS::Function</code> ...\n"],["simplify","CAS::Invert","CAS/Invert.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>-(-x) = x\n"],["simplify","CAS::Ln","CAS/Ln.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::NaryOp","CAS/NaryOp.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Op","CAS/Op.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Pow","CAS/Pow.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>0 ^ y = 0\n"],["simplify","CAS::Prod","CAS/Prod.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>x * 0 = x * y = 0\n"],["simplify","CAS::Sin","CAS/Sin.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Sqrt","CAS/Sqrt.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>√(x^z) = x^(z - 1/2)\n"],["simplify","CAS::Sum","CAS/Sum.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n<p>Simplifcation engine supports:\n<p>x + 0 = x\n"],["simplify","CAS::Tan","CAS/Tan.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Variable","CAS/Variable.html#method-i-simplify","()","<p>Simplification callback. The only possible simplification\nis returning\n<code>self</code>\n<p><strong>returns</strong>: <code>CAS::Variable</code> as …\n\n"],["simplify_dict","CAS::Op","CAS/Op.html#method-c-simplify_dict","(k)","<p>Returns an element of a\n"],["simplify_dictionary","CAS::Op","CAS/Op.html#method-i-simplify_dictionary","()","<p>Simplify dictionary performs a dictionary simplification\nthat is the class\nvariable <code>@@simplify_dict</code>\n<p><strong>returns</strong> …\n\n"],["sin","CAS","CAS.html#method-c-sin","(x)","<p>Shortcut for <code>CAS::Sin#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Sin</code> operation\n"],["size","CAS::Function","CAS/Function.html#method-c-size","()","<p>Return the number of functions defined\n<p><strong>returns</strong>: <code>Fixnum</code>\n\n"],["size","CAS::Variable","CAS/Variable.html#method-c-size","()","<p>Return the number of variable defined\n<p><strong>returns</strong>: <code>Fixnum</code>\n\n"],["smaller","CAS","CAS.html#method-c-smaller","(x, y)","<p>Shortcut creates <code>CAS::Smaller</code> object\n"],["smaller","CAS::Op","CAS/Op.html#method-i-smaller","(v)","<p>Shortcut for creating a smaller kind condition.\n<p><strong>argument</strong>: <code>CAS::Op</code> ther element of the\ncondition\n<p><strong>returns</strong> …\n"],["smaller_equal","CAS","CAS.html#method-c-smaller_equal","(x, y)","<p>Shortcut creates a <code>CAs::SmallerEqual</code> object\n"],["smaller_equal","CAS::Op","CAS/Op.html#method-i-smaller_equal","(v)","<p>Shortcut for creating a smaller equal kind condition.\n<p><strong>argument</strong>: <code>CAS::Op</code> ther element of the\ncondition …\n"],["sqrt","CAS","CAS.html#method-c-sqrt","(x)","<p>Shortcut for <code>CAS::Sqrt</code> initializer\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of square root\n<p><strong>returns</strong>: <code>CAS::Sqrt</code> new instance …\n"],["subs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs","(dt)","<p>Substituitions for both branches of the graph, same as\n<code>CAS::Op#subs</code>\n<p><strong>argument</strong>: <code>Hash</code> of substitutions\n<p><strong>returns</strong> …\n"],["subs","CAS::BoxCondition","CAS/BoxCondition.html#method-i-subs","(fd)","<p>Substitute in the central element using a dictionary\n<p><strong>returns</strong>: <code>Hash</code> of substitutions\n\n"],["subs","CAS::Condition","CAS/Condition.html#method-i-subs","(fd)","<p>Substitute in the two elements using a dictionary\n<p><strong>returns</strong>: <code>Hash</code> of substitutions\n\n"],["subs","CAS::Constant","CAS/Constant.html#method-i-subs","(_dt)","<p>Subs for a constant is a dummy method that returns always <code>self</code>\n<p><strong>argument</strong>: Unused argument\n<p><strong>returns</strong>: <code>CAS::Constant</code> …\n"],["subs","CAS::Function","CAS/Function.html#method-i-subs","(s)","<p>Substitutions in which a function is involved directly generates a\nCAS::Error unless the substitution …\n"],["subs","CAS::NaryOp","CAS/NaryOp.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n\n<pre>x, y = CAS::vars :x, :y\nf = (x ** 2) + ...</pre>\n"],["subs","CAS::Op","CAS/Op.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n\n<pre>x, y = CAS::vars :x, :y\nf = (x ** 2) + ...</pre>\n"],["subs","CAS::Variable","CAS/Variable.html#method-i-subs","(dt)","<p>Terminal substitutions for variables. If input datatable\ncontains the\nvariable will perform the substitution ...\n"],["subs_lhs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs_lhs","(dt)","<p>Substituitions for left branch of the graph, same as\n<code>CAS::Op#subs</code>\n<p><strong>argument</strong>: <code>Hash</code> of substitutions\n<p><strong>returns</strong> …\n"],["subs_rhs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs_rhs","(dt)","<p>Substituitions for left branch of the graph, same as\n<code>CAS::Op#subs</code>\n<p><strong>argument</strong>: <code>Hash</code> of substitutions\n<p><strong>returns</strong> …\n"],["tan","CAS","CAS.html#method-c-tan","(x)","<p>Shortcut for <code>CAS::Tan#new</code>\n<p><strong>argument</strong>: <code>CAS::Op</code> argument of the function\n<p><strong>returns</strong>: <code>CAS::Tan</code> operation\n"],["to_code","CAS::Abs","CAS/Abs.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Acos","CAS/Acos.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Asin","CAS/Asin.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Atan","CAS/Atan.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_code","()","<p>Code to be used in <code>CAS::BinaryOp#to_proc</code>\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_code","CAS::BoxCondition","CAS/BoxCondition.html#method-i-to_code","()","<p>Return the code that performs a condition evaluation\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_code","CAS::Condition","CAS/Condition.html#method-i-to_code","()","<p>Return the code that performs a condition evaluation\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_code","CAS::Cos","CAS/Cos.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Diff","CAS/Diff.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Div","CAS/Div.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Exp","CAS/Exp.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Function","CAS/Function.html#method-i-to_code","()","<p>Tries to convert an anonymous function into Ruby code will always raise a\n<code>CASError</code> because it\nis not ...\n"],["to_code","CAS::Invert","CAS/Invert.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Ln","CAS/Ln.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::NaryOp","CAS/NaryOp.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Op","CAS/Op.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Piecewise","CAS/Piecewise.html#method-i-to_code","()","<p>Convert the piecewise funtion to a String of Ruby code\n<p><strong>returns</strong>: <code>String</code> of code\n\n"],["to_code","CAS::Pow","CAS/Pow.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Prod","CAS/Prod.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Sin","CAS/Sin.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Sqrt","CAS/Sqrt.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Sum","CAS/Sum.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Tan","CAS/Tan.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_code","CAS::Variable","CAS/Variable.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p><strong>returns</strong>: <code>String</code> that represent Ruby …\n\n"],["to_dot","CAS","CAS.html#method-c-to_dot","(op)","<p>Return a string representation of the graph that is\na Graphviz tree.\nRequires a <code>CAS::Op</code> as argument. ...\n"],["to_dot","CAS::Constant","CAS/Constant.html#method-i-to_dot","()","<p>Return the local Graphviz node of the tree\n<p><strong>returns</strong>: <code>String</code> of local Graphiz node\n\n"],["to_dot","CAS::Variable","CAS/Variable.html#method-i-to_dot","()","<p>Return the local Graphviz node of the tree\n<p><strong>returns</strong>: <code>String</code> of local Graphiz node\n\n"],["to_latex","CAS::Exp","CAS/Exp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_latex","CAS::Ln","CAS/Ln.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_latex","CAS::MinMax","CAS/MinMax.html#method-i-to_latex","()","<p>Convert MinMax function into LaTeX representation\n<p><strong>returns</strong>: <code>String</code> of LaTeX code\n\n"],["to_latex","CAS::Piecewise","CAS/Piecewise.html#method-i-to_latex","()","<p>Convert piecewise function into LaTeX representation\n<p><strong>returns</strong>: <code>String</code> of LaTeX code\n\n"],["to_s","CAS::Abs","CAS/Abs.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Acos","CAS/Acos.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Asin","CAS/Asin.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Atan","CAS/Atan.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_s","()","<p>String representation of the tree\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::BoxCondition","CAS/BoxCondition.html#method-i-to_s","()","<p>Returns a string that represents the object to be printed\n<p><code>String</code>\n"],["to_s","CAS::Condition","CAS/Condition.html#method-i-to_s","()","<p>Returns a string that represents the object to be printed\n<p><code>String</code>\n"],["to_s","CAS::Constant","CAS/Constant.html#method-i-to_s","()","<p>The string representation of a constant is the value\nof the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Cos","CAS/Cos.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Diff","CAS/Diff.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Div","CAS/Div.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Exp","CAS/Exp.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Function","CAS/Function.html#method-i-to_s","()","<p>Returns a description <code>String</code> for the\n<code>CAS::Function</code>\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Invert","CAS/Invert.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Ln","CAS/Ln.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::MinMax","CAS/MinMax.html#method-i-to_s","()","<p>Returns a string representation for the current operation\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::NaryOp","CAS/NaryOp.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Op","CAS/Op.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Piecewise","CAS/Piecewise.html#method-i-to_s","()","<p>Convert the piecewise function into a String\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Pow","CAS/Pow.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Prod","CAS/Prod.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Sin","CAS/Sin.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Sqrt","CAS/Sqrt.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Sum","CAS/Sum.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["to_s","CAS::Tan","CAS/Tan.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::Variable","CAS/Variable.html#method-i-to_s","()","<p>Convert expression to string\n<p><strong>returns</strong>: <code>String</code> to print on screen\n\n"],["to_s","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p><strong>returns</strong>: <code>String</code>\n\n"],["vars","CAS","CAS.html#method-c-vars","(*name)","<p>Allows to define a series of new variables.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">x</span>, <span class=\"ruby-identifier\">y</span> = <span class=\"ruby-constant\">CAS</span><span class=\"ruby-operator\">::</span><span class=\"ruby-identifier\">vars</span> :<span class=\"ruby-identifier\">x</span>, :<span class=\"ruby-identifier\">y</span>\n</pre>\n<p><strong>argument</strong>: <code>Array</code> of Numeric\n"],["README","","README_md.html","","<p>RAGNI-CAS\n<p><img src=\"https://badge.fury.io/rb/ragni-cas.svg\">\n<img\nsrc=\"https://codeclimate.com/github/MatteoRagni/cas-rb/badges/gpa.svg\"> ...\n"]]}}