var search_data = {"index":{"searchIndex":["cas","abs","acos","asin","atan","binaryop","boxcondition","boxconditionclosed","boxconditionlowerclosed","boxconditionopen","boxconditionupperclosed","caserror","condition","constant","math","cos","diff","div","e_constant","equal","exp","greater","greaterequal","help","infinity_constant","invert","ln","minus_one_constant","math","max","min","minmax","neg_infinity_constant","naryop","one_constant","op","pi_constant","piecewise","pow","prod","sin","smaller","smallerequal","sqrt","sum","two_constant","tan","variable","zero_constant","fixnum","float","!=()","*()","*()","*()","**()","**()","**()","+()","+()","+()","-()","-()","-()","-@()","/()","/()","/()","==()","==()","==()","==()","==()","==()","==()","==()","==()","abs()","acos()","args()","args()","args()","args()","args()","args()","args()","as_proc()","asin()","assert()","atan()","binary_dot_graph()","box()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","const()","cos()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","equal()","equal()","exist?()","exp()","export_dot()","greater()","greater()","greater_equal()","greater_equal()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","invert()","limit()","list()","ln()","log()","max()","min()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","numeric_to_const()","overloaded_div()","overloaded_div()","overloaded_minus()","overloaded_minus()","overloaded_mul()","overloaded_mul()","overloaded_plus()","overloaded_plus()","overloaded_pow()","overloaded_pow()","pow()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","representative()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify_dictionary()","sin()","size()","smaller()","smaller()","smaller_equal()","smaller_equal()","sqrt()","subs()","subs()","subs()","subs()","subs()","subs()","subs()","subs_lhs()","subs_rhs()","tan()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_dot()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","vars()","readme"],"longSearchIndex":["cas","cas::abs","cas::acos","cas::asin","cas::atan","cas::binaryop","cas::boxcondition","cas::boxconditionclosed","cas::boxconditionlowerclosed","cas::boxconditionopen","cas::boxconditionupperclosed","cas::caserror","cas::condition","cas::constant","cas::constant::math","cas::cos","cas::diff","cas::div","cas::e_constant","cas::equal","cas::exp","cas::greater","cas::greaterequal","cas::help","cas::infinity_constant","cas::invert","cas::ln","cas::minus_one_constant","cas::math","cas::max","cas::min","cas::minmax","cas::neg_infinity_constant","cas::naryop","cas::one_constant","cas::op","cas::pi_constant","cas::piecewise","cas::pow","cas::prod","cas::sin","cas::smaller","cas::smallerequal","cas::sqrt","cas::sum","cas::two_constant","cas::tan","cas::variable","cas::zero_constant","fixnum","float","cas::op#!=()","cas::op#*()","fixnum#*()","float#*()","cas::op#**()","fixnum#**()","float#**()","cas::op#+()","fixnum#+()","float#+()","cas::op#-()","fixnum#-()","float#-()","cas::op#-@()","cas::op#/()","fixnum#/()","float#/()","cas::binaryop#==()","cas::boxcondition#==()","cas::condition#==()","cas::constant#==()","cas::equal#==()","cas::naryop#==()","cas::op#==()","cas::piecewise#==()","cas::variable#==()","cas::abs()","cas::acos()","cas::binaryop#args()","cas::boxcondition#args()","cas::condition#args()","cas::constant#args()","cas::naryop#args()","cas::op#args()","cas::variable#args()","cas::op#as_proc()","cas::asin()","cas::help::assert()","cas::atan()","cas::piecewise#binary_dot_graph()","cas::box()","cas::abs#call()","cas::acos#call()","cas::asin#call()","cas::atan#call()","cas::binaryop#call()","cas::boxcondition#call()","cas::boxconditionclosed#call()","cas::boxconditionlowerclosed#call()","cas::boxconditionopen#call()","cas::boxconditionupperclosed#call()","cas::condition#call()","cas::constant#call()","cas::cos#call()","cas::diff#call()","cas::div#call()","cas::equal#call()","cas::exp#call()","cas::greater#call()","cas::greaterequal#call()","cas::invert#call()","cas::ln#call()","cas::naryop#call()","cas::op#call()","cas::piecewise#call()","cas::pow#call()","cas::prod#call()","cas::sin#call()","cas::smaller#call()","cas::smallerequal#call()","cas::sqrt#call()","cas::sum#call()","cas::tan#call()","cas::variable#call()","cas::const()","cas::cos()","cas::binaryop#depend?()","cas::boxcondition#depend?()","cas::condition#depend?()","cas::constant#depend?()","cas::naryop#depend?()","cas::op#depend?()","cas::variable#depend?()","cas::abs#diff()","cas::acos#diff()","cas::asin#diff()","cas::atan#diff()","cas::binaryop#diff()","cas::boxcondition#diff()","cas::condition#diff()","cas::constant#diff()","cas::cos#diff()","cas::diff#diff()","cas::div#diff()","cas::exp#diff()","cas::invert#diff()","cas::ln#diff()","cas::naryop#diff()","cas::op#diff()","cas::piecewise#diff()","cas::pow#diff()","cas::prod#diff()","cas::sin#diff()","cas::sqrt#diff()","cas::sum#diff()","cas::tan#diff()","cas::variable#diff()","cas::binaryop#dot_graph()","cas::boxcondition#dot_graph()","cas::condition#dot_graph()","cas::constant#dot_graph()","cas::naryop#dot_graph()","cas::op#dot_graph()","cas::piecewise#dot_graph()","cas::variable#dot_graph()","cas::equal()","cas::op#equal()","cas::variable::exist?()","cas::exp()","cas::export_dot()","cas::greater()","cas::op#greater()","cas::greater_equal()","cas::op#greater_equal()","cas::binaryop#inspect()","cas::boxcondition#inspect()","cas::condition#inspect()","cas::constant#inspect()","cas::naryop#inspect()","cas::op#inspect()","cas::variable#inspect()","cas::invert()","cas::op#limit()","cas::variable::list()","cas::ln()","cas::log()","cas::max()","cas::min()","cas::binaryop::new()","cas::boxcondition::new()","cas::condition::new()","cas::constant::new()","cas::e_constant::new()","cas::infinity_constant::new()","cas::minus_one_constant::new()","cas::max::new()","cas::min::new()","cas::neg_infinity_constant::new()","cas::naryop::new()","cas::one_constant::new()","cas::op::new()","cas::pi_constant::new()","cas::piecewise::new()","cas::two_constant::new()","cas::variable::new()","cas::zero_constant::new()","cas::op::numeric_to_const()","fixnum#overloaded_div()","float#overloaded_div()","fixnum#overloaded_minus()","float#overloaded_minus()","fixnum#overloaded_mul()","float#overloaded_mul()","fixnum#overloaded_plus()","float#overloaded_plus()","fixnum#overloaded_pow()","float#overloaded_pow()","cas::pow()","cas::boxcondition#representative()","cas::boxconditionclosed#representative()","cas::boxconditionlowerclosed#representative()","cas::boxconditionopen#representative()","cas::boxconditionupperclosed#representative()","cas::condition#representative()","cas::equal#representative()","cas::greater#representative()","cas::greaterequal#representative()","cas::smaller#representative()","cas::smallerequal#representative()","cas::abs#simplify()","cas::acos#simplify()","cas::asin#simplify()","cas::atan#simplify()","cas::binaryop#simplify()","cas::boxcondition#simplify()","cas::condition#simplify()","cas::constant#simplify()","cas::cos#simplify()","cas::diff#simplify()","cas::div#simplify()","cas::exp#simplify()","cas::invert#simplify()","cas::ln#simplify()","cas::naryop#simplify()","cas::op#simplify()","cas::pow#simplify()","cas::prod#simplify()","cas::sin#simplify()","cas::sqrt#simplify()","cas::sum#simplify()","cas::tan#simplify()","cas::variable#simplify()","cas::op#simplify_dictionary()","cas::sin()","cas::variable::size()","cas::smaller()","cas::op#smaller()","cas::smaller_equal()","cas::op#smaller_equal()","cas::sqrt()","cas::binaryop#subs()","cas::boxcondition#subs()","cas::condition#subs()","cas::constant#subs()","cas::naryop#subs()","cas::op#subs()","cas::variable#subs()","cas::binaryop#subs_lhs()","cas::binaryop#subs_rhs()","cas::tan()","cas::abs#to_code()","cas::acos#to_code()","cas::asin#to_code()","cas::atan#to_code()","cas::binaryop#to_code()","cas::boxcondition#to_code()","cas::condition#to_code()","cas::cos#to_code()","cas::diff#to_code()","cas::div#to_code()","cas::exp#to_code()","cas::invert#to_code()","cas::ln#to_code()","cas::naryop#to_code()","cas::op#to_code()","cas::piecewise#to_code()","cas::pow#to_code()","cas::prod#to_code()","cas::sin#to_code()","cas::sqrt#to_code()","cas::sum#to_code()","cas::tan#to_code()","cas::variable#to_code()","cas::to_dot()","cas::abs#to_latex()","cas::acos#to_latex()","cas::asin#to_latex()","cas::atan#to_latex()","cas::binaryop#to_latex()","cas::boxcondition#to_latex()","cas::condition#to_latex()","cas::constant#to_latex()","cas::cos#to_latex()","cas::diff#to_latex()","cas::div#to_latex()","cas::e_constant#to_latex()","cas::exp#to_latex()","cas::infinity_constant#to_latex()","cas::invert#to_latex()","cas::ln#to_latex()","cas::minmax#to_latex()","cas::neg_infinity_constant#to_latex()","cas::naryop#to_latex()","cas::op#to_latex()","cas::pi_constant#to_latex()","cas::piecewise#to_latex()","cas::pow#to_latex()","cas::prod#to_latex()","cas::sin#to_latex()","cas::sqrt#to_latex()","cas::sum#to_latex()","cas::tan#to_latex()","cas::variable#to_latex()","cas::abs#to_s()","cas::acos#to_s()","cas::asin#to_s()","cas::atan#to_s()","cas::binaryop#to_s()","cas::boxcondition#to_s()","cas::condition#to_s()","cas::constant#to_s()","cas::cos#to_s()","cas::diff#to_s()","cas::div#to_s()","cas::e_constant#to_s()","cas::exp#to_s()","cas::infinity_constant#to_s()","cas::invert#to_s()","cas::ln#to_s()","cas::minus_one_constant#to_s()","cas::minmax#to_s()","cas::neg_infinity_constant#to_s()","cas::naryop#to_s()","cas::one_constant#to_s()","cas::op#to_s()","cas::pi_constant#to_s()","cas::piecewise#to_s()","cas::pow#to_s()","cas::prod#to_s()","cas::sin#to_s()","cas::sqrt#to_s()","cas::sum#to_s()","cas::two_constant#to_s()","cas::tan#to_s()","cas::variable#to_s()","cas::zero_constant#to_s()","cas::vars()",""],"info":[["CAS","","CAS.html","",""],["CAS::Abs","","CAS/Abs.html","","\n<pre>  _   _\n /_\\ | |__ ___\n/ _ \\| &#39;_ (_-&lt;</pre>\n<p>/_/ _<em>._</em>/__/\n"],["CAS::Acos","","CAS/Acos.html","","<p>Representation for the `arccos(x)` function. It is implemented as a\n`CAS::Op`. It is the inverse of the …\n"],["CAS::Asin","","CAS/Asin.html","","<p>Representation for the `arcsin(x)` function. It is implemented as a\n`CAS::Op`. It is the inverse of the …\n"],["CAS::Atan","","CAS/Atan.html","","<p>Representation for the `arctan(x)` function. It is implemented as a\n`CAS::Op`. It is the inverse of the …\n"],["CAS::BinaryOp","","CAS/BinaryOp.html","","<p>Binary operator\n"],["CAS::BoxCondition","","CAS/BoxCondition.html","","<p>BoxCondition class constructs a condition of the type:\n<p>“` L &lt; f(x) &lt; U “`\n<p>and this is a metaclass …\n"],["CAS::BoxConditionClosed","","CAS/BoxConditionClosed.html","","<p>Implements the box condition with both bounds closed\n<p>“` a ≤ f(x) ≤ b “`\n"],["CAS::BoxConditionLowerClosed","","CAS/BoxConditionLowerClosed.html","","<p>Implements the box condition with lower bound closed and upper open\n<p>“` a ≤ f(x) &lt; b “`\n"],["CAS::BoxConditionOpen","","CAS/BoxConditionOpen.html","","<p>Implements the box condition with both bounds are open\n<p>“` a &lt; f(x) &lt; b “`\n"],["CAS::BoxConditionUpperClosed","","CAS/BoxConditionUpperClosed.html","","<p>Implements the box condition with lower bound open and upper closed\n<p>“` a &lt; f(x) ≤ b “`\n"],["CAS::CASError","","CAS/CASError.html","",""],["CAS::Condition","","CAS/Condition.html","","<p>Condition class is a pseudo-class for all the other kind of conditions:\n\n<pre>* Equal\n* Greater\n* GreaterEqual ...</pre>\n"],["CAS::Constant","","CAS/Constant.html","","<p>Constant is a `CAS::Op` container for a `Numeric` value, that is not a\n`CAS::Variable`, thus its derivative …\n"],["CAS::Constant::Math","","CAS/Constant/Math.html","",""],["CAS::Cos","","CAS/Cos.html","","<p>Representation for the `cos(x)` function. It is implemented as a `CAS::Op`.\n"],["CAS::Diff","","CAS/Diff.html","","<p>Diff basic operation. It&#39;s a binary operation\n"],["CAS::Div","","CAS/Div.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>  <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>|   (_)_ __ | |) | \\ V / |<em>_</em>/|_|_/ “`\n"],["CAS::E_CONSTANT","","CAS/E_CONSTANT.html","","<p>Class that represents the constant E (e)\n"],["CAS::Equal","","CAS/Equal.html","","<p>This class is a Condition for two equal function\n"],["CAS::Exp","","CAS/Exp.html","","<p>Representation for the `e^x` function. It is implemented as a `CAS::Op`\n"],["CAS::Greater","","CAS/Greater.html","","<p>This class is a Condition for right smaller function\n"],["CAS::GreaterEqual","","CAS/GreaterEqual.html","","<p>This class is a condition for right smaller or equal function\n"],["CAS::Help","","CAS/Help.html","","<p>Support functions are in this separate Helper class\n"],["CAS::INFINITY_CONSTANT","","CAS/INFINITY_CONSTANT.html","","<p>Class that represents the constant Infinity (∞)\n"],["CAS::Invert","","CAS/Invert.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>                 <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>|_ _|_ <em>_</em> <em>_</em> _ _| |_\n\n<pre>| || &#39; \\ V / -_) &#39;_|  _|</pre>\n"],["CAS::Ln","","CAS/Ln.html","","<p>Representation for the `log(x)` function. It is implemented as a `CAS::Op`\n"],["CAS::MINUS_ONE_CONSTANT","","CAS/MINUS_ONE_CONSTANT.html","","<p>Class that represents the constant Minus One (-1)\n"],["CAS::Math","","CAS/Math.html","",""],["CAS::Max","","CAS/Max.html","","<p>Max class represent a piecewise in which the condition is `f(x) ≥ g(x)`.\nDerivate a `CAS::Max` will return …\n"],["CAS::Min","","CAS/Min.html","","<p>Min class represent a piecewise in which the condition is `f(x) ≤ g(x)`.\nDerivate a `CAS::Min` will return …\n"],["CAS::MinMax","","CAS/MinMax.html","","<p>Class MinMax is an intermediate class for Min and Max functions. It\ncontains shared code and methods …\n"],["CAS::NEG_INFINITY_CONSTANT","","CAS/NEG_INFINITY_CONSTANT.html","","<p>Class that represents the constant Negative Infinity (-∞)\n"],["CAS::NaryOp","","CAS/NaryOp.html","","<p>This is an attempt to build some sort of node in the graph that has\narbitrary number of childs node. …\n"],["CAS::ONE_CONSTANT","","CAS/ONE_CONSTANT.html","","<p>Class that represents the constant One (1)\n"],["CAS::Op","","CAS/Op.html","","\n<pre> ___\n/ _ \\ _ __</pre>\n<p>| (_) | &#39;_ \\\n\n<pre>\\___/| .__/\n     |_|</pre>\n"],["CAS::PI_CONSTANT","","CAS/PI_CONSTANT.html","","<p>Class that represents the constant Pi (π)\n"],["CAS::Piecewise","","CAS/Piecewise.html","","<p>Piecewise function. The function returns when called a result that dependes\nupon the evaluation of a …\n"],["CAS::Pow","","CAS/Pow.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>\n</pre>\n<p>| _ _<em>__</em> __ __ |  _/ _ \\ V  V / |_| _<em>_/</em>/_/ “`\n"],["CAS::Prod","","CAS/Prod.html","","<p>Product class. Performs the product between two elements. This class will\nbe soon modified as an n-ary …\n"],["CAS::Sin","","CAS/Sin.html","","<p>Representation for the `sin(x)` function. It is implemented as a `CAS::Op`\n"],["CAS::Smaller","","CAS/Smaller.html","","<p>This class is a Condition for left smaller function\n"],["CAS::SmallerEqual","","CAS/SmallerEqual.html","","<p>This class is a Condition for left smaller or equal function\n"],["CAS::Sqrt","","CAS/Sqrt.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>           <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>/ __| __ _ _ _| |_ __ / _` | &#39;_|  _| |<em>_</em>/__, |_|  __|\n\n<pre>|_|</pre>\n"],["CAS::Sum","","CAS/Sum.html","","<p>**Sum basic operation**. As for now it is implemented as a simple binary\noperation. It will be implemented …\n"],["CAS::TWO_CONSTANT","","CAS/TWO_CONSTANT.html","","<p>Class that represents the constant Two (2)\n"],["CAS::Tan","","CAS/Tan.html","","<p>Representation for the `tan(x)` function. It is implemented as a `CAS::Op`.\n"],["CAS::Variable","","CAS/Variable.html","","<p>Container for a variable. It can be resolved in a numerical value. It can\nalso be used for derivatives. …\n"],["CAS::ZERO_CONSTANT","","CAS/ZERO_CONSTANT.html","","<p>Class that represents the constant Zero (0)\n"],["Fixnum","","Fixnum.html","","<p>Overloading operators for Fixnum. Operations that are oveloaded are:\n<p>`overloaded_plus` for `+`\n<p>`overloaded_minus` …\n"],["Float","","Float.html","","<p>Overloading operators for Float. Operations that are oveloaded are:\n<p>`overloaded_plus` for `+`\n<p>`overloaded_minus` …\n"],["!=","CAS::Op","CAS/Op.html#method-i-21-3D","(op)","<p>Disequality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on …\n"],["*","CAS::Op","CAS/Op.html#method-i-2A","(op)","<p>Returns a product of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["*","Fixnum","Fixnum.html#method-i-2A","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["*","Float","Float.html#method-i-2A","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["**","CAS::Op","CAS/Op.html#method-i-2A-2A","(op)","<p>Returns the power of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["**","Fixnum","Fixnum.html#method-i-2A-2A","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["**","Float","Float.html#method-i-2A-2A","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["+","CAS::Op","CAS/Op.html#method-i-2B","(op)","<p>Returns a sum of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["+","Fixnum","Fixnum.html#method-i-2B","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation. If\n"],["+","Float","Float.html#method-i-2B","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation. If\n"],["-","CAS::Op","CAS/Op.html#method-i-2D","(op)","<p>Returns a difference of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["-","Fixnum","Fixnum.html#method-i-2D","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["-","Float","Float.html#method-i-2D","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["-@","CAS::Op","CAS/Op.html#method-i-2D-40","()","<p>Unary operator for inversion of a `CAS::Op`\n<p>-&gt; `CAS::Op` new object\n"],["/","CAS::Op","CAS/Op.html#method-i-2F","(op)","<p>Returns a division of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["/","Fixnum","Fixnum.html#method-i-2F","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["/","Float","Float.html#method-i-2F","(a)","<p>If `a` is a `CAS::Op` transform self in a `CAS::Const` and return a\nsymbolic operation\n"],["==","CAS::BinaryOp","CAS/BinaryOp.html#method-i-3D-3D","(op)","<p>Comparison with other `CAS::Op`. This is *<strong>not</strong>* a math\noperation.\n<p>&lt;- `CAS::Op` to be compared against …\n"],["==","CAS::BoxCondition","CAS/BoxCondition.html#method-i-3D-3D","(cond)","<p>Return true if two BoxConditions are equal, false if different\n<p>&lt;- `CAS::Op` operator to check against …\n"],["==","CAS::Condition","CAS/Condition.html#method-i-3D-3D","(op)","<p>Return true if two functions are equal, false if different\n<p>&lt;- `CAS::Op` operator to check against for …\n"],["==","CAS::Constant","CAS/Constant.html#method-i-3D-3D","(op)","<p>Check if a constant is equal to another `CAS::Op` object\n<p>&lt;- `CAs::Op` -&gt; `TrueClass` or `FalseClass` …\n"],["==","CAS::Equal","CAS/Equal.html#method-i-3D-3D","(op)","<p>Return true if two functions are equal, false if different\n<p>&lt;- `CAS::Op` operator to check against for …\n"],["==","CAS::NaryOp","CAS/NaryOp.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on the …\n"],["==","CAS::Op","CAS/Op.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on the …\n"],["==","CAS::Piecewise","CAS/Piecewise.html#method-i-3D-3D","(op)","<p>Checks if two `CAS::Piecewise` are equal. Checks equality on all functions+\nand conditions\n<p>&lt;- `CAS::Op` …\n"],["==","CAS::Variable","CAS/Variable.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on the …\n"],["abs","CAS","CAS.html#method-c-abs","(x)",""],["acos","CAS","CAS.html#method-c-acos","(x)","<p>Shortcut for `CAS::Acos#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Acos` operation\n"],["args","CAS::BinaryOp","CAS/BinaryOp.html#method-i-args","()","<p>Returns an array of all the variables that are in the graph\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::BoxCondition","CAS/BoxCondition.html#method-i-args","()","<p>Returns an array of variables of the central function\n<p>-&gt; `Array` of `CAS::Variable`\n"],["args","CAS::Condition","CAS/Condition.html#method-i-args","()","<p>Returns an array of variables of the two functions in the condition\n<p>-&gt; `Array` of `CAS::Variable`\n"],["args","CAS::Constant","CAS/Constant.html#method-i-args","()","<p>Args of a constant is an empty `Array`\n<p>-&gt; `Array` empty\n"],["args","CAS::NaryOp","CAS/NaryOp.html#method-i-args","()","<p>Returns a list of all `CAS::Variable`s of the current tree\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::Op","CAS/Op.html#method-i-args","()","<p>Returns a list of all `CAS::Variable`s of the current tree\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::Variable","CAS/Variable.html#method-i-args","()","<p>Returns an array containing `self`\n<p>-&gt; `Array` containing `self`\n"],["as_proc","CAS::Op","CAS/Op.html#method-i-as_proc","(bind=nil)","<p>Evaluates the proc against a given context. It is like having a snapshot of\nthe tree transformed in a …\n"],["asin","CAS","CAS.html#method-c-asin","(x)","<p>Shortcut for `CAS::Asin#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Asin` operation\n"],["assert","CAS::Help","CAS/Help.html#method-c-assert","(obj, type)","<p>Check input `obj.class` against a `type` class raises an ArgumentError if\ncheck fails\n"],["atan","CAS","CAS.html#method-c-atan","(x)","<p>Shortcut for `CAS::Atan#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Atan` operation\n"],["binary_dot_graph","CAS::Piecewise","CAS/Piecewise.html#method-i-binary_dot_graph","()",""],["box","CAS","CAS.html#method-c-box","(x, a, b, type=:closed)","<p>Shortcut for creating a new box condition. It requires four arguments:\n<p>&lt;- `CAS::Op` function for condition …\n"],["call","CAS::Abs","CAS/Abs.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Acos","CAS/Acos.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Asin","CAS/Asin.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Atan","CAS/Atan.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::BinaryOp","CAS/BinaryOp.html#method-i-call","(_fd)","<p>Same `CAS::Op#call`\n<p>&lt;- `Hash` of values -&gt; `Numeric` for result\n"],["call","CAS::BoxCondition","CAS/BoxCondition.html#method-i-call","(_fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::BoxConditionClosed","CAS/BoxConditionClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate relation\n<p>&lt;- `Hash` with feed dictionary -&gt; …\n"],["call","CAS::BoxConditionLowerClosed","CAS/BoxConditionLowerClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate relation\n<p>&lt;- `Hash` with feed dictionary -&gt; …\n"],["call","CAS::BoxConditionOpen","CAS/BoxConditionOpen.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate relation\n<p>&lt;- `Hash` with feed dictionary -&gt; …\n"],["call","CAS::BoxConditionUpperClosed","CAS/BoxConditionUpperClosed.html#method-i-call","(fd)","<p>Function call will evaluate box condition to evaluate relation\n<p>&lt;- `Hash` with feed dictionary -&gt; …\n"],["call","CAS::Condition","CAS/Condition.html#method-i-call","(_fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::Constant","CAS/Constant.html#method-i-call","(_f)","<p>Calling a constant will return the value of the constant itself.\n<p>&lt;- Unused argument -&gt; `Numeric` …\n"],["call","CAS::Cos","CAS/Cos.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Diff","CAS/Diff.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Div","CAS/Div.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Equal","CAS/Equal.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::Exp","CAS/Exp.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Greater","CAS/Greater.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::GreaterEqual","CAS/GreaterEqual.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::Invert","CAS/Invert.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Ln","CAS/Ln.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::NaryOp","CAS/NaryOp.html#method-i-call","(fd)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\ndepends upon promotions). As …\n"],["call","CAS::Op","CAS/Op.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Piecewise","CAS/Piecewise.html#method-i-call","(fd)","<p>Executes the condition. If it is `true` it returns the first function, else\nit returns the value of the …\n"],["call","CAS::Pow","CAS/Pow.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Prod","CAS/Prod.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Sin","CAS/Sin.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Smaller","CAS/Smaller.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::SmallerEqual","CAS/SmallerEqual.html#method-i-call","(fd)","<p>Function call will evaluate left and right functions to solve the relation\n<p>&lt;- `Hash` with feed dictionary …\n"],["call","CAS::Sqrt","CAS/Sqrt.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Sum","CAS/Sum.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Tan","CAS/Tan.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["call","CAS::Variable","CAS/Variable.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\n(depends upon promotions).  …\n"],["const","CAS","CAS.html#method-c-const","(*val)","<p>Allows to define a series of new constants.\n<p>“` ruby a, b = CAS::const 1.0, 100 “`\n<p>&lt;- `Array` of Numeric …\n"],["cos","CAS","CAS.html#method-c-cos","(x)","<p>Shortcut for `CAS::Cos#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Cos` operation\n"],["depend?","CAS::BinaryOp","CAS/BinaryOp.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a `CAS::Variable` and it\nis one of the recursve method …\n"],["depend?","CAS::BoxCondition","CAS/BoxCondition.html#method-i-depend-3F","(v)","<p>Returns true if one the central function depends upon the expression\nincluded\n<p>&lt;- `CAS::Op` operator …\n"],["depend?","CAS::Condition","CAS/Condition.html#method-i-depend-3F","(v)","<p>Returns true if one of the two functions depends upon the expression\nincluded\n<p>&lt;- `CAS::Op` operator …\n"],["depend?","CAS::Constant","CAS/Constant.html#method-i-depend-3F","(_v)","<p>There is no dependency in a constant, thus this method will always return\nfalse\n<p>&lt;- Unused argument …\n"],["depend?","CAS::NaryOp","CAS/NaryOp.html#method-i-depend-3F","(v)","<p>Returns the dependencies of the operation. Require a `CAS::Variable` and it\nis one of the recursive method …\n"],["depend?","CAS::Op","CAS/Op.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a `CAS::Variable` and it\nis one of the recursve method …\n"],["depend?","CAS::Variable","CAS/Variable.html#method-i-depend-3F","(v)","<p>Returns `TrueClass` if argument of the function is equal to `self`\n<p>&lt;- `CAS::Op` -&gt; `TrueClass` or …\n"],["diff","CAS::Abs","CAS/Abs.html#method-i-diff","(v)","<p>Performs the absolute value of a `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Acos","CAS/Acos.html#method-i-diff","(v)",""],["diff","CAS::Asin","CAS/Asin.html#method-i-diff","(v)","<p>Return the derivative of the `arcsin(x)` function using the chain rule. The\ninput is a `CAS::Op`\n<p>&lt;- …\n"],["diff","CAS::Atan","CAS/Atan.html#method-i-diff","(v)","<p>Return the derivative of the `arctan(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::BinaryOp","CAS/BinaryOp.html#method-i-diff","(v)","<p>This method returns an array with the derivatives of the two branches of\nthe node. This method is usually …\n"],["diff","CAS::BoxCondition","CAS/BoxCondition.html#method-i-diff","(v)","<p>Performs the derivative of the box condition. The derivative of a box\ncondition is a `CAS::Equal` object …\n"],["diff","CAS::Condition","CAS/Condition.html#method-i-diff","(v)","<p>Performs the derivative of the two elements:\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Constant","CAS/Constant.html#method-i-diff","(_v)","<p>Evaluates the derivative of a constant. The derivative is always a\n`CAS::Zero`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Cos","CAS/Cos.html#method-i-diff","(v)","<p>Return the derivative of the `cos(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::Diff","CAS/Diff.html#method-i-diff","(v)","<p>Performs the difference between two `CAS::Op`s\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Div","CAS/Div.html#method-i-diff","(v)","<p>Performs the division between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Exp","CAS/Exp.html#method-i-diff","(v)","<p>Return the derivative of the `sin(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::Invert","CAS/Invert.html#method-i-diff","(v)","<p>Performs the inversion of a `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Ln","CAS/Ln.html#method-i-diff","(v)","<p>Return the derivative of the `log(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::NaryOp","CAS/NaryOp.html#method-i-diff","(v)","<p>Return a list of derivative using the chain rule. The input is a operation:\n<p>“`\n\n<pre>f(x) = g(x) + h(x) + l(x) ...</pre>\n"],["diff","CAS::Op","CAS/Op.html#method-i-diff","(v)","<p>Return the derivative of the operation using the chain rule The input is a\n`CAS::Op` because it can handle …\n"],["diff","CAS::Piecewise","CAS/Piecewise.html#method-i-diff","(v)","<p>Derivative of a function is performed as derivative of the two internal\nfunctions while condition is …\n"],["diff","CAS::Pow","CAS/Pow.html#method-i-diff","(v)","<p>Performs the power between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Prod","CAS/Prod.html#method-i-diff","(v)","<p>Performs the product between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Sin","CAS/Sin.html#method-i-diff","(v)","<p>Return the derivative of the `sin(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::Sqrt","CAS/Sqrt.html#method-i-diff","(v)","<p>Performs the square root between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Sum","CAS/Sum.html#method-i-diff","(v)","<p>Performs the sum between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Tan","CAS/Tan.html#method-i-diff","(v)","<p>Return the derivative of the `tan(x)` function using the chain rule. The\ninput is a `CAS::Op` because …\n"],["diff","CAS::Variable","CAS/Variable.html#method-i-diff","(v)","<p>Returns the derivative of a variable\n<p>“`\n\n<pre>dx      dx\n-- = 1; -- = 0\ndx      dy</pre>\n"],["dot_graph","CAS::BinaryOp","CAS/BinaryOp.html#method-i-dot_graph","()","<p>Returns the graphviz representation of the current node\n<p>&lt;- `?` unused removed -&gt; `String`\n"],["dot_graph","CAS::BoxCondition","CAS/BoxCondition.html#method-i-dot_graph","()","<p>Returns the dot graphviz representation of the code\n<p>-&gt; `String`\n"],["dot_graph","CAS::Condition","CAS/Condition.html#method-i-dot_graph","(node)","<p>Returns the dot graphviz representation of the code\n<p>-&gt; `String`\n"],["dot_graph","CAS::Constant","CAS/Constant.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p>-&gt; `String` of local Graphiz node\n"],["dot_graph","CAS::NaryOp","CAS/NaryOp.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p>&lt;- `?` unused variable (TODO: to be removed) -&gt; `String` …\n"],["dot_graph","CAS::Op","CAS/Op.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p>-&gt; `String` of local Graphiz node\n"],["dot_graph","CAS::Piecewise","CAS/Piecewise.html#method-i-dot_graph","()","<p>Convert piecewise function into a dot graphviz representation\n<p>-&gt; `String`\n"],["dot_graph","CAS::Variable","CAS/Variable.html#method-i-dot_graph","()","<p>Return the local Graphviz node of the tree\n<p>-&gt; `String` of local Graphiz node\n"],["equal","CAS","CAS.html#method-c-equal","(x, y)","<p>Shortcut creates a `CAS::Equal` object\n"],["equal","CAS::Op","CAS/Op.html#method-i-equal","(v)","<p>Shortcut for creating equality condition.\n<p>&lt;- `CAS::Op` ther element of the condition -&gt; `CAS::Equal` …\n"],["exist?","CAS::Variable","CAS/Variable.html#method-c-exist-3F","(name)","<p>Returns `true` if a variable already exists\n<p>&lt;- `Object` that represent the variable -&gt; `TrueClass` …\n"],["exp","CAS","CAS.html#method-c-exp","(x)","<p>Shortcut for `CAS::Exp#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Exp` operation\n"],["export_dot","CAS","CAS.html#method-c-export_dot","(fl, op)","<p>Export the input `CAS::Op` graphviz representation to a file. &lt;-\n`String` with filename &lt;- `CAS::Op` …\n"],["greater","CAS","CAS.html#method-c-greater","(x, y)","<p>Shortcut creates a `CAS::Greater` object\n"],["greater","CAS::Op","CAS/Op.html#method-i-greater","(v)","<p>Shortcut for creating greater kind condition.\n<p>&lt;- `CAS::Op` ther element of the condition -&gt; `CAS::Greater` …\n"],["greater_equal","CAS","CAS.html#method-c-greater_equal","(x, y)","<p>Shortcut creates a `CAS::GreaterEqual` object\n"],["greater_equal","CAS::Op","CAS/Op.html#method-i-greater_equal","(v)","<p>Shortcut for creating a greater equal kind condition.\n<p>&lt;- `CAS::Op` ther element of the condition -&gt; …\n"],["inspect","CAS::BinaryOp","CAS/BinaryOp.html#method-i-inspect","()","<p>Inspector\n<p>-&gt; `String`\n"],["inspect","CAS::BoxCondition","CAS/BoxCondition.html#method-i-inspect","()","<p>Inspector for the class. It is class specific\n<p>-&gt; `String`\n"],["inspect","CAS::Condition","CAS/Condition.html#method-i-inspect","()","<p>Inspector for the class. It is class specific\n<p>-&gt; `String`\n"],["inspect","CAS::Constant","CAS/Constant.html#method-i-inspect","()","<p>Inspection for `CAS::Constant` class\n<p>-&gt; `String`\n"],["inspect","CAS::NaryOp","CAS/NaryOp.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; `String`\n"],["inspect","CAS::Op","CAS/Op.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; `String`\n"],["inspect","CAS::Variable","CAS/Variable.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; `String`\n"],["invert","CAS","CAS.html#method-c-invert","(x)",""],["limit","CAS::Op","CAS/Op.html#method-i-limit","(a, b, type=:closed)","<p>Shortcut for creating a new box condition. It requires limits and type:\n<p>&lt;- `CAS::Constant` lower limit …\n"],["list","CAS::Variable","CAS/Variable.html#method-c-list","()","<p>Returns the `Hash` that contains all the variable\n<p>-&gt; `Hash`\n"],["ln","CAS","CAS.html#method-c-ln","(x)","<p>Shortcut for `CAS::Ln#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Ln` operation\n"],["log","CAS","CAS.html#method-c-log","(x)","<p>Shortcut for `CAS::Ln#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Ln` operation\n"],["max","CAS","CAS.html#method-c-max","(x, y)",""],["min","CAS","CAS.html#method-c-min","(x, y)",""],["new","CAS::BinaryOp","CAS/BinaryOp.html#method-c-new","(x, y)","<p>The binary operator inherits from the `CAS::Op`, even if it is defined as a\nnode with two possible branches. …\n"],["new","CAS::BoxCondition","CAS/BoxCondition.html#method-c-new","(x, lower, upper)","<p>Initializes a new box condition. A function is required as central term,\nwhile the second and the third …\n"],["new","CAS::Condition","CAS/Condition.html#method-c-new","(x, y)","<p>Initializer for a new condition. The condition is implicit in the class,\nthus a pure `CAS::Condition` …\n"],["new","CAS::Constant","CAS/Constant.html#method-c-new","(x)",""],["new","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-c-new","()","<p>Initializer for the E constant\n<p>-&gt; `CAS::E_CONSTANT` new instance\n"],["new","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-c-new","()","<p>Initializer for the infinity constant\n<p>-&gt; `CAS::INFINITY_CONSTANT` new instance\n"],["new","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-c-new","()","<p>Initializer for the minus one constant\n<p>-&gt; `CAS::MINUS_ONE_CONSTANT` new instance\n"],["new","CAS::Max","CAS/Max.html#method-c-new","(x, y)","<p>To initialize `CAS::Max` only the two functions are necessary. The\ncondition is automatically generated …\n"],["new","CAS::Min","CAS/Min.html#method-c-new","(x, y)","<p>To initialize `CAS::Min` only the two functions are necessary. The\ncondition is automatically generated …\n"],["new","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-c-new","()","<p>Initializer for the negative infinity constant\n<p>-&gt; `CAS::NEG_INFINITY_CONSTANT` new instance\n"],["new","CAS::NaryOp","CAS/NaryOp.html#method-c-new","(*xs)","<p>Initialize a new empty N-elements operation container. This is a virtual\nclass, and other must inherit …\n"],["new","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-c-new","()","<p>Initializer for the one constant\n<p>-&gt; `CAS::ONE_CONSTANT` new instance\n"],["new","CAS::Op","CAS/Op.html#method-c-new","(x)","<p>Initialize a new empty operation container. This is a virtual class and the\nother must inherit from this …\n"],["new","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-c-new","()","<p>Initializer for the pi constant\n<p>-&gt; `CAS::PI_CONSTANT` new instance\n"],["new","CAS::Piecewise","CAS/Piecewise.html#method-c-new","(x, y, condition)","<p>Initialize a new piecewise function. It requires first the function that\nreturns when condition is true, …\n"],["new","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-c-new","()","<p>Initializer for the two constant\n<p>-&gt; `CAS::TWO_CONSTANT` new instance\n"],["new","CAS::Variable","CAS/Variable.html#method-c-new","(name)","<p>Variable is a container for an atomic simbol that becomes a number when\n`CAS::Op#call` method is used. …\n"],["new","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-c-new","()","<p>Initializer for the zero constant\n<p>-&gt; `CAS::ZERO_CONSTANT` new instance\n"],["numeric_to_const","CAS::Op","CAS/Op.html#method-c-numeric_to_const","(x)",""],["overloaded_div","Fixnum","Fixnum.html#method-i-overloaded_div","(a)",""],["overloaded_div","Float","Float.html#method-i-overloaded_div","(a)",""],["overloaded_minus","Fixnum","Fixnum.html#method-i-overloaded_minus","(a)",""],["overloaded_minus","Float","Float.html#method-i-overloaded_minus","(a)",""],["overloaded_mul","Fixnum","Fixnum.html#method-i-overloaded_mul","(a)",""],["overloaded_mul","Float","Float.html#method-i-overloaded_mul","(a)",""],["overloaded_plus","Fixnum","Fixnum.html#method-i-overloaded_plus","(a)","<p>Setting aliasese\n"],["overloaded_plus","Float","Float.html#method-i-overloaded_plus","(a)","<p>Setting aliasese\n"],["overloaded_pow","Fixnum","Fixnum.html#method-i-overloaded_pow","(a)",""],["overloaded_pow","Float","Float.html#method-i-overloaded_pow","(a)",""],["pow","CAS","CAS.html#method-c-pow","(x, y)",""],["representative","CAS::BoxCondition","CAS/BoxCondition.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionClosed","CAS/BoxConditionClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionLowerClosed","CAS/BoxConditionLowerClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionOpen","CAS/BoxConditionOpen.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::BoxConditionUpperClosed","CAS/BoxConditionUpperClosed.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Condition","CAS/Condition.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Equal","CAS/Equal.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Greater","CAS/Greater.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::GreaterEqual","CAS/GreaterEqual.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::Smaller","CAS/Smaller.html#method-i-representative","()","<p>Saves some required elements\n"],["representative","CAS::SmallerEqual","CAS/SmallerEqual.html#method-i-representative","()","<p>Saves some required elements\n"],["simplify","CAS::Abs","CAS/Abs.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Acos","CAS/Acos.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Asin","CAS/Asin.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Atan","CAS/Atan.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::BinaryOp","CAS/BinaryOp.html#method-i-simplify","()","<p>Executes simplifications of the two branches of the graph\n<p>-&gt; `CAS::BinaryOp` as `self`\n"],["simplify","CAS::BoxCondition","CAS/BoxCondition.html#method-i-simplify","()","<p>Simplify left and right term of the operator\n<p>-&gt; `CAS::BoxCondition`\n"],["simplify","CAS::Condition","CAS/Condition.html#method-i-simplify","()","<p>Simplify left and right term of the operator\n<p>-&gt; `CAS::Condition`\n"],["simplify","CAS::Constant","CAS/Constant.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Cos","CAS/Cos.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Diff","CAS/Diff.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Div","CAS/Div.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Exp","CAS/Exp.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Invert","CAS/Invert.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Ln","CAS/Ln.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::NaryOp","CAS/NaryOp.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Op","CAS/Op.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Pow","CAS/Pow.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Prod","CAS/Prod.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Sin","CAS/Sin.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Sqrt","CAS/Sqrt.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Sum","CAS/Sum.html#method-i-simplify","()","<p>Same as `CAS::Op`\n<p>Simplifcation engine supports:\n<p>x + 0 = x\n"],["simplify","CAS::Tan","CAS/Tan.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Variable","CAS/Variable.html#method-i-simplify","()","<p>Simplification callback. The only possible simplification is returning\n`self`\n<p>-&gt; `CAS::Variable` as …\n"],["simplify_dictionary","CAS::Op","CAS/Op.html#method-i-simplify_dictionary","()","<p>Simplify dictionary performs a dictionary simplification that is the class\nvariable `@@simplify_dict` …\n"],["sin","CAS","CAS.html#method-c-sin","(x)","<p>Shortcut for `CAS::Sin#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Sin` operation\n"],["size","CAS::Variable","CAS/Variable.html#method-c-size","()","<p>Return the number of variable defined\n<p>-&gt; `Fixnum`\n"],["smaller","CAS","CAS.html#method-c-smaller","(x, y)","<p>Shortcut creates `CAS::Smaller` object\n"],["smaller","CAS::Op","CAS/Op.html#method-i-smaller","(v)","<p>Shortcut for creating a smaller kind condition.\n<p>&lt;- `CAS::Op` ther element of the condition -&gt; `CAS::Smaller` …\n"],["smaller_equal","CAS","CAS.html#method-c-smaller_equal","(x, y)","<p>Shortcut creates a `CAs::SmallerEqual` object\n"],["smaller_equal","CAS::Op","CAS/Op.html#method-i-smaller_equal","(v)","<p>Shortcut for creating a smaller equal kind condition.\n<p>&lt;- `CAS::Op` ther element of the condition -&gt; …\n"],["sqrt","CAS","CAS.html#method-c-sqrt","(x)",""],["subs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs","(dt)","<p>Substituitions for both branches of the graph, same as `CAS::Op#subs`\n<p>&lt;- `Hash` of substitutions -&gt; …\n"],["subs","CAS::BoxCondition","CAS/BoxCondition.html#method-i-subs","(fd)","<p>Substitute in the central element using a dictionary\n<p>-&gt; `Hash` of substitutions\n"],["subs","CAS::Condition","CAS/Condition.html#method-i-subs","(fd)","<p>Substitute in the two elements using a dictionary\n<p>-&gt; `Hash` of substitutions\n"],["subs","CAS::Constant","CAS/Constant.html#method-i-subs","(_dt)","<p>Subs for a constant is a dummy method that returns always `self`\n<p>&lt;- Unused argument -&gt; `CAS::Constant` …\n"],["subs","CAS::NaryOp","CAS/NaryOp.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n<p>“` ruby x, y = CAS::vars :x, :y f = (x …\n"],["subs","CAS::Op","CAS/Op.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n<p>“` ruby x, y = CAS::vars :x, :y f = (x …\n"],["subs","CAS::Variable","CAS/Variable.html#method-i-subs","(dt)","<p>Terminal substitutions for variables. If input datatable contains the\nvariable will perform the substitution …\n"],["subs_lhs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs_lhs","(dt)","<p>Substituitions for left branch of the graph, same as `CAS::Op#subs`\n<p>&lt;- `Hash` of substitutions -&gt; …\n"],["subs_rhs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs_rhs","(dt)","<p>Substituitions for left branch of the graph, same as `CAS::Op#subs`\n<p>&lt;- `Hash` of substitutions -&gt; …\n"],["tan","CAS","CAS.html#method-c-tan","(x)","<p>Shortcut for `CAS::Tan#new`\n<p>&lt;- `CAS::Op` argument of the function -&gt; `CAS::Tan` operation\n"],["to_code","CAS::Abs","CAS/Abs.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Acos","CAS/Acos.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Asin","CAS/Asin.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Atan","CAS/Atan.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_code","()","<p>Code to be used in `CAS::BinaryOp#to_proc`\n<p>-&gt; `String`\n"],["to_code","CAS::BoxCondition","CAS/BoxCondition.html#method-i-to_code","()","<p>Return the code that performs a condition evaluation\n<p>-&gt; `String`\n"],["to_code","CAS::Condition","CAS/Condition.html#method-i-to_code","()","<p>Return the code that performs a condition evaluation\n<p>-&gt; `String`\n"],["to_code","CAS::Cos","CAS/Cos.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Diff","CAS/Diff.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Div","CAS/Div.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Exp","CAS/Exp.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Invert","CAS/Invert.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Ln","CAS/Ln.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::NaryOp","CAS/NaryOp.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Op","CAS/Op.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Piecewise","CAS/Piecewise.html#method-i-to_code","()","<p>Convert the piecewise funtion to a String of Ruby code\n<p>-&gt; `String` of code\n"],["to_code","CAS::Pow","CAS/Pow.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Prod","CAS/Prod.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Sin","CAS/Sin.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Sqrt","CAS/Sqrt.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Sum","CAS/Sum.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Tan","CAS/Tan.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Variable","CAS/Variable.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_dot","CAS","CAS.html#method-c-to_dot","(op)","<p>Return a string representation of the graph that is a Graphviz tree.\nRequires a `CAS::Op` as argument. …\n"],["to_latex","CAS::Abs","CAS/Abs.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op\n"],["to_latex","CAS::Acos","CAS/Acos.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Asin","CAS/Asin.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Atan","CAS/Atan.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::BoxCondition","CAS/BoxCondition.html#method-i-to_latex","()","<p>Returns a string that can be used for printing LaTeX version of the box\ncondition\n<p>`String`\n"],["to_latex","CAS::Condition","CAS/Condition.html#method-i-to_latex","()","<p>Returns a string that can be used for printing LaTeX version of the\ncondition\n<p>`String`\n"],["to_latex","CAS::Constant","CAS/Constant.html#method-i-to_latex","()","<p>Return latex representation of current `CAS::Op`\n<p>-&gt; `String`\n"],["to_latex","CAS::Cos","CAS/Cos.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Diff","CAS/Diff.html#method-i-to_latex","()","<p>Returns a latex representation of the current Op\n"],["to_latex","CAS::Div","CAS/Div.html#method-i-to_latex","()","<p>Returns the latex reppresentation of the current Op\n"],["to_latex","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_latex","()","<p>Latex representation for the constant\n<p>-&gt; `String`\n"],["to_latex","CAS::Exp","CAS/Exp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_latex","()","<p>Latex representation for the constant\n<p>-&gt; `String`\n"],["to_latex","CAS::Invert","CAS/Invert.html#method-i-to_latex","()","<p>Returns the latex representation of the current op\n"],["to_latex","CAS::Ln","CAS/Ln.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::MinMax","CAS/MinMax.html#method-i-to_latex","()","<p>Convert MinMax function into LaTeX representation\n<p>-&gt; `String` of LaTeX code\n"],["to_latex","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-i-to_latex","()","<p>Latex representation for the constant\n<p>-&gt; `String`\n"],["to_latex","CAS::NaryOp","CAS/NaryOp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Op","CAS/Op.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_latex","()","<p>Latex representation for the constant\n<p>-&gt; `String`\n"],["to_latex","CAS::Piecewise","CAS/Piecewise.html#method-i-to_latex","()","<p>Convert piecewise function into LaTeX representation\n<p>-&gt; `String` of LaTeX code\n"],["to_latex","CAS::Pow","CAS/Pow.html#method-i-to_latex","()","<p>Returns the latex representation of the op\n"],["to_latex","CAS::Prod","CAS/Prod.html#method-i-to_latex","()","<p>Returns a latex represstation of the Op\n"],["to_latex","CAS::Sin","CAS/Sin.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Sqrt","CAS/Sqrt.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op\n"],["to_latex","CAS::Sum","CAS/Sum.html#method-i-to_latex","()","<p>Returns a latex represenntation of the current Op\n"],["to_latex","CAS::Tan","CAS/Tan.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Variable","CAS/Variable.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_s","CAS::Abs","CAS/Abs.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Acos","CAS/Acos.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::Asin","CAS/Asin.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::Atan","CAS/Atan.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_s","()","<p>String representation of the tree\n<p>-&gt; `String`\n"],["to_s","CAS::BoxCondition","CAS/BoxCondition.html#method-i-to_s","()","<p>Returns a string that represents the object to be printed\n<p>`String`\n"],["to_s","CAS::Condition","CAS/Condition.html#method-i-to_s","()","<p>Returns a string that represents the object to be printed\n<p>`String`\n"],["to_s","CAS::Constant","CAS/Constant.html#method-i-to_s","()","<p>The string representation of a constant is the value of the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Cos","CAS/Cos.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::Diff","CAS/Diff.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Div","CAS/Div.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Exp","CAS/Exp.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Invert","CAS/Invert.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Ln","CAS/Ln.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::MinMax","CAS/MinMax.html#method-i-to_s","()","<p>Returns a string representation for the current operation\n<p>-&gt; `String`\n"],["to_s","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::NaryOp","CAS/NaryOp.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Op","CAS/Op.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Piecewise","CAS/Piecewise.html#method-i-to_s","()","<p>Convert the piecewise function into a String\n<p>-&gt; `String`\n"],["to_s","CAS::Pow","CAS/Pow.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Prod","CAS/Prod.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Sin","CAS/Sin.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::Sqrt","CAS/Sqrt.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Sum","CAS/Sum.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["to_s","CAS::Tan","CAS/Tan.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::Variable","CAS/Variable.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-i-to_s","()","<p>String representation for the constant\n<p>-&gt; `String`\n"],["vars","CAS","CAS.html#method-c-vars","(*name)","<p>Allows to define a series of new variables.\n<p>“` ruby x, y = CAS::vars :x, :y “`\n<p>&lt;- `Array` of Numeric …\n"],["README","","README_md.html","","<p>CAS-RB\n<p><img src=\"https://badge.fury.io/rb/ragni-cas.svg\">\n<img\nsrc=\"https://codeclimate.com/github/MatteoRagni/cas-rb/badges/gpa.svg\"> ...\n"]]}}