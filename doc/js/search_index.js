var search_data = {"index":{"searchIndex":["alpha","cas","abs","acos","asin","atan","binaryop","caserror","condition","constant","cos","diff","div","e_constant","equal","exp","greater","greaterequal","help","infinity_constant","invert","ln","minus_one_constant","one_constant","op","pi_constant","piecewise","pow","prod","sin","smaller","smallerequal","sqrt","sum","two_constant","tan","variable","zero_constant","!=()","!=()","*()","**()","+()","-()","-@()","/()","==()","==()","==()","==()","==()","==()","==()","==()","==()","abs()","acos()","args()","args()","args()","args()","args()","as_proc()","asin()","assert()","atan()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","const()","cos()","create_method()","depend?()","depend?()","depend?()","depend?()","depend?()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","equal()","equal()","exist?()","exp()","export_dot()","greater()","greater()","greater_equal()","greater_equal()","inspect()","inspect()","inspect()","inspect()","inspect()","invert()","list()","ln()","log()","max()","min()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","pow()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","sin()","size()","smaller()","smaller()","smaller_equal()","smaller_equal()","sqrt()","subs()","subs()","subs()","tan()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_dot()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","vars()","changelog","readme","matteoragni.pem","ragni-cas.gemspec"],"longSearchIndex":["alpha","cas","cas::abs","cas::acos","cas::asin","cas::atan","cas::binaryop","cas::caserror","cas::condition","cas::constant","cas::cos","cas::diff","cas::div","cas::e_constant","cas::equal","cas::exp","cas::greater","cas::greaterequal","cas::help","cas::infinity_constant","cas::invert","cas::ln","cas::minus_one_constant","cas::one_constant","cas::op","cas::pi_constant","cas::piecewise","cas::pow","cas::prod","cas::sin","cas::smaller","cas::smallerequal","cas::sqrt","cas::sum","cas::two_constant","cas::tan","cas::variable","cas::zero_constant","cas::condition#!=()","cas::op#!=()","cas::op#*()","cas::op#**()","cas::op#+()","cas::op#-()","cas::op#-@()","cas::op#/()","cas::binaryop#==()","cas::condition#==()","cas::constant#==()","cas::diff#==()","cas::op#==()","cas::piecewise#==()","cas::prod#==()","cas::sum#==()","cas::variable#==()","cas::abs()","cas::acos()","cas::binaryop#args()","cas::condition#args()","cas::constant#args()","cas::op#args()","cas::variable#args()","cas::op#as_proc()","cas::asin()","cas::help::assert()","cas::atan()","cas::abs#call()","cas::acos#call()","cas::asin#call()","cas::atan#call()","cas::binaryop#call()","cas::constant#call()","cas::cos#call()","cas::diff#call()","cas::div#call()","cas::exp#call()","cas::invert#call()","cas::ln#call()","cas::op#call()","cas::piecewise#call()","cas::pow#call()","cas::prod#call()","cas::sin#call()","cas::sqrt#call()","cas::sum#call()","cas::tan#call()","cas::variable#call()","cas::const()","cas::cos()","alpha#create_method()","cas::binaryop#depend?()","cas::condition#depend?()","cas::constant#depend?()","cas::op#depend?()","cas::variable#depend?()","cas::abs#diff()","cas::acos#diff()","cas::asin#diff()","cas::atan#diff()","cas::binaryop#diff()","cas::condition#diff()","cas::constant#diff()","cas::cos#diff()","cas::diff#diff()","cas::div#diff()","cas::exp#diff()","cas::invert#diff()","cas::ln#diff()","cas::op#diff()","cas::piecewise#diff()","cas::pow#diff()","cas::prod#diff()","cas::sin#diff()","cas::sqrt#diff()","cas::sum#diff()","cas::tan#diff()","cas::variable#diff()","cas::binaryop#dot_graph()","cas::condition#dot_graph()","cas::constant#dot_graph()","cas::op#dot_graph()","cas::piecewise#dot_graph()","cas::variable#dot_graph()","cas::equal()","cas::op#equal()","cas::variable::exist?()","cas::exp()","cas::export_dot()","cas::greater()","cas::op#greater()","cas::greater_equal()","cas::op#greater_equal()","cas::binaryop#inspect()","cas::condition#inspect()","cas::constant#inspect()","cas::op#inspect()","cas::variable#inspect()","cas::invert()","cas::variable::list()","cas::ln()","cas::log()","cas::max()","cas::min()","alpha::new()","cas::binaryop::new()","cas::condition::new()","cas::constant::new()","cas::e_constant::new()","cas::equal::new()","cas::greater::new()","cas::greaterequal::new()","cas::infinity_constant::new()","cas::minus_one_constant::new()","cas::one_constant::new()","cas::op::new()","cas::pi_constant::new()","cas::piecewise::new()","cas::smaller::new()","cas::smallerequal::new()","cas::two_constant::new()","cas::variable::new()","cas::zero_constant::new()","cas::pow()","cas::abs#simplify()","cas::acos#simplify()","cas::asin#simplify()","cas::atan#simplify()","cas::binaryop#simplify()","cas::condition#simplify()","cas::constant#simplify()","cas::cos#simplify()","cas::diff#simplify()","cas::div#simplify()","cas::exp#simplify()","cas::invert#simplify()","cas::ln#simplify()","cas::op#simplify()","cas::pow#simplify()","cas::prod#simplify()","cas::sin#simplify()","cas::sqrt#simplify()","cas::sum#simplify()","cas::tan#simplify()","cas::variable#simplify()","cas::sin()","cas::variable::size()","cas::smaller()","cas::op#smaller()","cas::smaller_equal()","cas::op#smaller_equal()","cas::sqrt()","cas::binaryop#subs()","cas::condition#subs()","cas::op#subs()","cas::tan()","cas::abs#to_code()","cas::acos#to_code()","cas::asin#to_code()","cas::atan#to_code()","cas::binaryop#to_code()","cas::condition#to_code()","cas::cos#to_code()","cas::diff#to_code()","cas::div#to_code()","cas::exp#to_code()","cas::invert#to_code()","cas::ln#to_code()","cas::op#to_code()","cas::piecewise#to_code()","cas::pow#to_code()","cas::prod#to_code()","cas::sin#to_code()","cas::sqrt#to_code()","cas::sum#to_code()","cas::tan#to_code()","cas::variable#to_code()","cas::to_dot()","cas::abs#to_s()","cas::acos#to_s()","cas::asin#to_s()","cas::atan#to_s()","cas::binaryop#to_s()","cas::condition#to_s()","cas::constant#to_s()","cas::cos#to_s()","cas::diff#to_s()","cas::div#to_s()","cas::e_constant#to_s()","cas::exp#to_s()","cas::infinity_constant#to_s()","cas::invert#to_s()","cas::ln#to_s()","cas::minus_one_constant#to_s()","cas::one_constant#to_s()","cas::op#to_s()","cas::pi_constant#to_s()","cas::piecewise#to_s()","cas::pow#to_s()","cas::prod#to_s()","cas::sin#to_s()","cas::sqrt#to_s()","cas::sum#to_s()","cas::two_constant#to_s()","cas::tan#to_s()","cas::variable#to_s()","cas::zero_constant#to_s()","cas::vars()","","","",""],"info":[["Alpha","","Alpha.html","",""],["CAS","","CAS.html","",""],["CAS::Abs","","CAS/Abs.html","","<p>_ _\n /<em>\\ | |</em>_ &lt;b&gt;_\n / _ | &#39;_\n(&lt;em&gt;-&lt;\n/&lt;/em&gt;/ __.&lt;/b&gt;/__/\n"],["CAS::Acos","","CAS/Acos.html","","<p>_\n /&lt;em&gt;\\ &lt;em&gt;_ <em>_</em> &lt;b&gt;_\n / _ / <em>/ _\n(</em>-&lt;\n/<em>/ __</em>_&lt;/b&gt;/&lt;/em&gt;&lt;/em&gt;/\n"],["CAS::Asin","","CAS/Asin.html","","<p>_ _\n /<em>\\ &lt;b&gt;(&lt;em&gt;)</em> _\n / _ \\ (&lt;em&gt;-&lt; | &#39;\n\\\n/&lt;/em&gt;/ _\\/&lt;/b&gt;/&lt;/em&gt;| ...\n"],["CAS::Atan","","CAS/Atan.html","","<p>_ _\n /<em>| |</em> __ _ _ _\n / _ \\ &lt;em&gt;/ &lt;em&gt;` | &#39;\n\\\n/&lt;/em&gt;/ __&lt;/em&gt;_<em>,</em>|<em>||</em>|\n"],["CAS::BinaryOp","","CAS/BinaryOp.html","","<p>&lt;em&gt;&lt;em&gt;_ _ &lt;b&gt;_\n| _ |<em>)</em> _ &lt;em&gt;_ _ _ _ _ _\n/ _ \\ _ &lt;em&gt;_\n| _ \\ | &#39;  ...\n"],["CAS::CASError","","CAS/CASError.html","",""],["CAS::Condition","","CAS/Condition.html","",""],["CAS::Constant","","CAS/Constant.html","","<p>&lt;b&gt;_ _ _\n / <strong>|</strong>_ _ _ &lt;b&gt;| |_ __ _ _ <em>|\n|</em>\n| (&lt;/b&gt;/ _ \\ &#39; (&lt;em&gt;-&lt; &lt;em&gt;/ ...\n"],["CAS::Cos","","CAS/Cos.html","","<p>&lt;em&gt;&lt;em&gt;_\n / <strong>|</strong>&lt;/em&gt; &lt;b&gt;_\n|\n(&lt;/b&gt;/ _ (&lt;/em&gt;-&lt;\n _<strong>_</strong>/__/\n"],["CAS::Diff","","CAS/Diff.html","","<p>_&lt;em&gt;_ _ &lt;em&gt;_ &lt;em&gt;_\n| (&lt;/em&gt;)/ &lt;em&gt;|/\n&lt;em&gt;|\n| |) | | &lt;em&gt;| ...\n"],["CAS::Div","","CAS/Div.html","","<p>&lt;b&gt;_ _\n| (<em>)</em> &lt;em&gt;_\n| |) | \\ V\n/\n|&lt;/em&gt;&lt;/b&gt;/|_|_/\n"],["CAS::E_CONSTANT","","CAS/E_CONSTANT.html","","<p><em>_</em>\n| &lt;b&gt;|\n| &lt;em&gt;|\n|&lt;/em&gt;&lt;/b&gt;|\n"],["CAS::Equal","","CAS/Equal.html","",""],["CAS::Exp","","CAS/Exp.html","","<p>&lt;em&gt;&lt;em&gt;_ _\n| &lt;b&gt;|_ <em>_</em> __ &lt;b&gt;_ _ _\n&lt;b&gt;_ _ <em>| |</em>\n| <em>|\\ \\ / &#39;</em> / _ \\ &#39; ...\n"],["CAS::Greater","","CAS/Greater.html","",""],["CAS::GreaterEqual","","CAS/GreaterEqual.html","",""],["CAS::Help","","CAS/Help.html","","<p>Support functions are in this separate Helper class\n"],["CAS::INFINITY_CONSTANT","","CAS/INFINITY_CONSTANT.html","","<p>&lt;em&gt;&lt;em&gt;_ &lt;em&gt;_ _ _ _\n|&lt;/em&gt; <em>|</em> _ /\n<em>(</em>)&lt;/em&gt; _ (&lt;/em&gt;) |_ _ _\n | || ...\n"],["CAS::Invert","","CAS/Invert.html","","<p>&lt;b&gt;_ _\n|_ <em>|</em> <em>_</em> <em>_</em> _ <em>| |</em>\n | || &#39;\n\\ V / -<em>) &#39;</em>| &lt;em&gt;|\n|&lt;/em&gt;&lt;/b&gt;|<em>||/||\n_</em>|\n"],["CAS::Ln","","CAS/Ln.html","","<p>_ _ _ _\n| | &lt;b&gt;_ <em>_ _ __ _ _ () |</em>| |_ _ &lt;em&gt;_\n|\n|&lt;/em&gt;<em>/ _ / &lt;em&gt;<code>/ _</code> | &#39;</em>| | ...\n"],["CAS::MINUS_ONE_CONSTANT","","CAS/MINUS_ONE_CONSTANT.html","","\n<pre class=\"ruby\"> <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>&lt;b&gt;&lt;em&gt;/ |\n|&lt;/em&gt;&lt;/b&gt;| |\n |_|\n"],["CAS::ONE_CONSTANT","","CAS/ONE_CONSTANT.html","","<p>&lt;b&gt;_\n / _ \\ _ _ &lt;b&gt;_\n| (<em>) | &#39; / -</em>)\n\n_&lt;/b&gt;/|<em>||</em>_&lt;/b&gt;|\n"],["CAS::Op","","CAS/Op.html","","<p>&lt;b&gt;_\n / _ \\ _ &lt;em&gt;_\n| (&lt;/em&gt;) | &#39;_ \\\n _&lt;/b&gt;/|\n._&lt;em&gt;/\n |&lt;/em&gt;| ...\n"],["CAS::PI_CONSTANT","","CAS/PI_CONSTANT.html","","<p><em>_</em> &lt;b&gt;_\n| _ _ &lt;em&gt;|\n| &lt;em&gt;/| |\n|&lt;/em&gt;|\n|&lt;/em&gt;&lt;/b&gt;|\n"],["CAS::Piecewise","","CAS/Piecewise.html","",""],["CAS::Pow","","CAS/Pow.html","","<p>&lt;b&gt;_\n| _ _&lt;/b&gt;&lt;em&gt;_ __ &lt;em&gt;_\n| &lt;em&gt;/ _ \\ V V\n/\n|&lt;/em&gt;| _&lt;/em&gt;&lt;/em&gt;/ ...\n"],["CAS::Prod","","CAS/Prod.html","","<p>&lt;em&gt;&lt;em&gt;_ _\n| _ _ _ <em>_</em> &lt;em&gt;&lt;em&gt;| |\n| <em>/\n&#39;</em>/ _ / &lt;em&gt;` |\n|&lt;/em&gt;| ...\n"],["CAS::Sin","","CAS/Sin.html","","<p>&lt;em&gt;&lt;em&gt;_ _\n/ &lt;b&gt;(<em>)</em> _\n__ \\ | &#39;\n\\\n|&lt;/b&gt;&lt;/em&gt;/&lt;/em&gt;|<em>||</em>|\n"],["CAS::Smaller","","CAS/Smaller.html","",""],["CAS::SmallerEqual","","CAS/SmallerEqual.html","",""],["CAS::Sqrt","","CAS/Sqrt.html","","<p>&lt;em&gt;&lt;em&gt;_ _\n/ &lt;b&gt;| __ _ _ <em>| |</em>\n__ / <em>` |\n&#39;</em>| &lt;em&gt;|\n|&lt;/em&gt;&lt;/b&gt;/_&lt;/em&gt;, ...\n"],["CAS::Sum","","CAS/Sum.html","","<p>&lt;em&gt;&lt;em&gt;_\n/ &lt;b&gt;|_ _ _ &lt;em&gt;_\n_&lt;/em&gt; \\ || |\n&#39; \\\n|&lt;/b&gt;&lt;/em&gt;/_,&lt;/em&gt;| ...\n"],["CAS::TWO_CONSTANT","","CAS/TWO_CONSTANT.html","","<p><em>_</em>\n|_ <em>|</em> __ <em>_</em>\n | | \\ V V / _ \\\n |<em>| //_</em>_/\n"],["CAS::Tan","","CAS/Tan.html","","<p><em>_</em>\n|_ <em>|</em> _ _ _\n | |/ &lt;em&gt;` | &#39; \\\n\n|&lt;/em&gt;|_<em>,</em>|<em>||</em>|\n"],["CAS::Variable","","CAS/Variable.html","","<p>&lt;em&gt;_ &lt;em&gt;_ _ _ _\n\\ \\ / /&lt;/em&gt; _ _\n<em>(</em>)&lt;/em&gt;_ <em>| || |</em>&lt;em&gt;_\n \\ V / <code><em>|\n&#39;_|</em></code> ...\n"],["CAS::ZERO_CONSTANT","","CAS/ZERO_CONSTANT.html","","<p><em>_</em> <em>_</em> &lt;b&gt;_\n|_ / &lt;b&gt;| _ / _ \\\n / /| <em>|| /\n(</em>) |\n/&lt;/b&gt;<em>|</em>&lt;/b&gt;|<em>|</em>&lt;em&gt;_&lt;/em&gt;/\n...\n"],["!=","CAS::Condition","CAS/Condition.html#method-i-21-3D","(op)",""],["!=","CAS::Op","CAS/Op.html#method-i-21-3D","(op)","<p>Disequality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on ...\n"],["*","CAS::Op","CAS/Op.html#method-i-2A","(op)","<p>Returns a product of two <code>CAS::Op</code>s\n<p>&lt;- <code>CAS::Op</code> tree\n-&gt; <code>CAS::Op</code> new object\n"],["**","CAS::Op","CAS/Op.html#method-i-2A-2A","(op)","<p>Returns the power of two <code>CAS::Op</code>s\n<p>&lt;- <code>CAS::Op</code> tree\n-&gt; <code>CAS::Op</code> new object\n"],["+","CAS::Op","CAS/Op.html#method-i-2B","(op)","<p>Returns a sum of two <code>CAS::Op</code>s\n<p>&lt;- <code>CAS::Op</code> tree\n-&gt; <code>CAS::Op</code> new object\n"],["-","CAS::Op","CAS/Op.html#method-i-2D","(op)","<p>Returns a difference of two <code>CAS::Op</code>s\n<p>&lt;- <code>CAS::Op</code> tree\n-&gt; <code>CAS::Op</code> new object\n"],["-@","CAS::Op","CAS/Op.html#method-i-2D-40","()","<p>Unary operator for inversion of a <code>CAS::Op</code>\n<p>-&gt; <code>CAS::Op</code> new object\n"],["/","CAS::Op","CAS/Op.html#method-i-2F","(op)","<p>Returns a division of two <code>CAS::Op</code>s\n<p>&lt;- <code>CAS::Op</code> tree\n-&gt; <code>CAS::Op</code> new object\n"],["==","CAS::BinaryOp","CAS/BinaryOp.html#method-i-3D-3D","(op)","<p>Comparison with other <code>CAS::Op</code>. This is <strong>not</strong> a\nmath operation.\n<p>&lt;- <code>CAS::Op</code> to be compared against\n-&gt; ...\n"],["==","CAS::Condition","CAS/Condition.html#method-i-3D-3D","(op)",""],["==","CAS::Constant","CAS/Constant.html#method-i-3D-3D","(op)","<p>Same as <code>CAS::Op</code>\n"],["==","CAS::Diff","CAS/Diff.html#method-i-3D-3D","(op)","<p>Same as <code>CAS::Op</code>\n"],["==","CAS::Op","CAS/Op.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded\n:warning: this\noperates on the graph, not on the ...\n"],["==","CAS::Piecewise","CAS/Piecewise.html#method-i-3D-3D","(op)",""],["==","CAS::Prod","CAS/Prod.html#method-i-3D-3D","(op)","<p>Same as <code>CAS::Op</code>\n"],["==","CAS::Sum","CAS/Sum.html#method-i-3D-3D","(op)","<p>Same as <code>CAS::Op</code>\n"],["==","CAS::Variable","CAS/Variable.html#method-i-3D-3D","(op)","<p>Same as <code>CAS::Op</code>\n"],["abs","CAS","CAS.html#method-c-abs","(x)",""],["acos","CAS","CAS.html#method-c-acos","(x)",""],["args","CAS::BinaryOp","CAS/BinaryOp.html#method-i-args","()","<p>Returns an array of all the variables that are in the graph\n<p>-&gt; <code>Array</code> of <code>CAS::Variable</code>s\n"],["args","CAS::Condition","CAS/Condition.html#method-i-args","()",""],["args","CAS::Constant","CAS/Constant.html#method-i-args","()","<p>Same as <code>CAS::Op</code>\n"],["args","CAS::Op","CAS/Op.html#method-i-args","()","<p>Returns a list of all <code>CAS::Variable</code>s of the current tree\n<p>-&gt; <code>Array</code> of <code>CAS::Variable</code>s\n"],["args","CAS::Variable","CAS/Variable.html#method-i-args","()","<p>Same as <code>CAS::Op</code>\n"],["as_proc","CAS::Op","CAS/Op.html#method-i-as_proc","(bind=nil)","<p>Evaluates the proc against a given context. It is like having a\nsnapshot of\nthe tree transformed in a ...\n"],["asin","CAS","CAS.html#method-c-asin","(x)",""],["assert","CAS::Help","CAS/Help.html#method-c-assert","(obj, type)","<p>Check input <code>obj.class</code> against a <code>type</code> class\nraises\nan ArgumentError if check fails\n"],["atan","CAS","CAS.html#method-c-atan","(x)",""],["call","CAS::Abs","CAS/Abs.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Acos","CAS/Acos.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Asin","CAS/Asin.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Atan","CAS/Atan.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::BinaryOp","CAS/BinaryOp.html#method-i-call","(fd)","<p>Same <code>CAS::Op#call</code>\n<p>&lt;- <code>Hash</code> of values\n-&gt; <code>Numeric</code> for result\n"],["call","CAS::Constant","CAS/Constant.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Cos","CAS/Cos.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Diff","CAS/Diff.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Div","CAS/Div.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Exp","CAS/Exp.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Invert","CAS/Invert.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Ln","CAS/Ln.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Op","CAS/Op.html#method-i-call","(f)","<p>Call resolves the operation tree in a <code>Numeric</code> (if\n<code>Fixnum</code>)\nor <code>Float</code> depends upon promotions).\nAs\ninput, ...\n"],["call","CAS::Piecewise","CAS/Piecewise.html#method-i-call","(fd)",""],["call","CAS::Pow","CAS/Pow.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Prod","CAS/Prod.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Sin","CAS/Sin.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Sqrt","CAS/Sqrt.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Sum","CAS/Sum.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Tan","CAS/Tan.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["call","CAS::Variable","CAS/Variable.html#method-i-call","(f)","<p>Same as <code>CAS::Op</code>\n"],["const","CAS","CAS.html#method-c-const","(*val)","<p>Allows to define a series of new constants.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">a</span>, <span class=\"ruby-identifier\">b</span> = <span class=\"ruby-constant\">CAS</span><span class=\"ruby-operator\">::</span><span class=\"ruby-identifier\">const</span> <span class=\"ruby-value\">1.0</span>, <span class=\"ruby-value\">100</span>\n</pre>\n<p>&lt;- <code>Array</code> of Numeric\n-&gt; <code>Array</code> ...\n"],["cos","CAS","CAS.html#method-c-cos","(x)",""],["create_method","Alpha","Alpha.html#method-i-create_method","(name, block)",""],["depend?","CAS::BinaryOp","CAS/BinaryOp.html#method-i-depend-3F","(v)","<p>Same as <code>CAS::Op#depend?</code>\n"],["depend?","CAS::Condition","CAS/Condition.html#method-i-depend-3F","(v)",""],["depend?","CAS::Constant","CAS/Constant.html#method-i-depend-3F","(v)","<p>Same as <code>CAS::Op</code>\n"],["depend?","CAS::Op","CAS/Op.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a\n<code>CAS::Variable</code>\nand it is one of the recursve method ...\n"],["depend?","CAS::Variable","CAS/Variable.html#method-i-depend-3F","(v)","<p>Same as <code>CAS::Op</code>\n"],["diff","CAS::Abs","CAS/Abs.html#method-i-diff","(v)","<p>Performs the absolute value of a <code>CAS::Op</code>\n\n<pre>d\n---- |f(x)| = f&#39;(x) * (f(x) / |f(x)|)\n dx</pre>\n"],["diff","CAS::Acos","CAS/Acos.html#method-i-diff","(v)",""],["diff","CAS::Asin","CAS/Asin.html#method-i-diff","(v)",""],["diff","CAS::Atan","CAS/Atan.html#method-i-diff","(v)",""],["diff","CAS::BinaryOp","CAS/BinaryOp.html#method-i-diff","(v)","<p>This method returns an array with the derivatives of the two branches\nof\nthe node. This method is usually ...\n"],["diff","CAS::Condition","CAS/Condition.html#method-i-diff","(v)",""],["diff","CAS::Constant","CAS/Constant.html#method-i-diff","(v)","<p>The derivative of a constant is always zero\n"],["diff","CAS::Cos","CAS/Cos.html#method-i-diff","(v)",""],["diff","CAS::Diff","CAS/Diff.html#method-i-diff","(v)","<p>Performs the difference between two <code>CAS::Op</code>s\n\n<pre>d\n---- (f(x) - g(x)) = f&#39;(x) - g&#39;(x)\n dx</pre>\n"],["diff","CAS::Div","CAS/Div.html#method-i-diff","(v)","<p>Performs the division between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) / g(x)) = (f&#39;(x) * g(x) - f(x) * g&#39;(x))/(g(x)^2) ...</pre>\n"],["diff","CAS::Exp","CAS/Exp.html#method-i-diff","(v)",""],["diff","CAS::Invert","CAS/Invert.html#method-i-diff","(v)","<p>Performs the inversion of a <code>CAS::Op</code>\n\n<pre>d\n---- (-f(x)) = -f&#39;(x)\n dx</pre>\n"],["diff","CAS::Ln","CAS/Ln.html#method-i-diff","(v)",""],["diff","CAS::Op","CAS/Op.html#method-i-diff","(v)","<p>Return the derivative of the operation using the chain rule\nThe input is a\n<code>CAS::Op</code> because it can handle ...\n"],["diff","CAS::Piecewise","CAS/Piecewise.html#method-i-diff","(v)",""],["diff","CAS::Pow","CAS/Pow.html#method-i-diff","(v)","<p>Performs the power between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x)^a) = f(x)^(a - 1) * a * f&#39;(x)\n dx\n\n  d\n---- (a^f(x)) ...</pre>\n"],["diff","CAS::Prod","CAS/Prod.html#method-i-diff","(v)","<p>Performs the product between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) * g(x)) = f&#39;(x) * g(x) + f(x) * g&#39;(x)\n dx</pre>\n"],["diff","CAS::Sin","CAS/Sin.html#method-i-diff","(v)",""],["diff","CAS::Sqrt","CAS/Sqrt.html#method-i-diff","(v)","<p>Performs the square root between two <code>CAS::Op</code>\n\n<pre>d\n---- √f(x) = 1/2 * f&#39;(x) * √f(x)\n dx</pre>\n"],["diff","CAS::Sum","CAS/Sum.html#method-i-diff","(v)","<p>Performs the sum between two <code>CAS::Op</code>\n\n<pre>d\n---- (f(x) + g(x)) = f&#39;(x) + g&#39;(x)\n dx</pre>\n"],["diff","CAS::Tan","CAS/Tan.html#method-i-diff","(v)",""],["diff","CAS::Variable","CAS/Variable.html#method-i-diff","(v)","<p>Returns the derivative of a variable\n\n<pre>dx      dx\n -- = 1; -- = 0\n dx      dy</pre>\n<p>&lt;- <code>CAS::Op</code> for the derivative …\n"],["dot_graph","CAS::BinaryOp","CAS/BinaryOp.html#method-i-dot_graph","(node)","<p>Returns the graphviz representation of the current node\n<p>&lt;- <code>?</code> to be removed\n-&gt; <code>String</code>\n"],["dot_graph","CAS::Condition","CAS/Condition.html#method-i-dot_graph","(node)",""],["dot_graph","CAS::Constant","CAS/Constant.html#method-i-dot_graph","(node)","<p>Same as <code>CAS::Op</code>\n"],["dot_graph","CAS::Op","CAS/Op.html#method-i-dot_graph","(node)","<p>Return the local Graphviz node of the tree\n<p>&lt;- <code>?</code> unused variable (TODO: to be removed)\n-&gt;\n<code>String</code> ...\n"],["dot_graph","CAS::Piecewise","CAS/Piecewise.html#method-i-dot_graph","(node)",""],["dot_graph","CAS::Variable","CAS/Variable.html#method-i-dot_graph","(node)","<p>Same as <code>CAS::Op</code>\n"],["equal","CAS","CAS.html#method-c-equal","(x, y)",""],["equal","CAS::Op","CAS/Op.html#method-i-equal","(v)",""],["exist?","CAS::Variable","CAS/Variable.html#method-c-exist-3F","(name)","<p>Returns <code>true</code> if a variable already exists\n<p>&lt;- <code>Object</code> that represent the variable\n-&gt;\n<code>TrueClass</code> if ...\n"],["exp","CAS","CAS.html#method-c-exp","(x)",""],["export_dot","CAS","CAS.html#method-c-export_dot","(fl, op)","<p>Export the input <code>CAS::Op</code> graphviz representation to a\nfile.\n&lt;- <code>String</code> with filename\n&lt;- <code>CAS::Op</code>\n...\n"],["greater","CAS","CAS.html#method-c-greater","(x, y)",""],["greater","CAS::Op","CAS/Op.html#method-i-greater","(v)",""],["greater_equal","CAS","CAS.html#method-c-greater_equal","(x, y)",""],["greater_equal","CAS::Op","CAS/Op.html#method-i-greater_equal","(v)",""],["inspect","CAS::BinaryOp","CAS/BinaryOp.html#method-i-inspect","()","<p>Inspector\n<p>-&gt; <code>String</code>\n"],["inspect","CAS::Condition","CAS/Condition.html#method-i-inspect","()",""],["inspect","CAS::Constant","CAS/Constant.html#method-i-inspect","()","<p>Same as <code>CAS::Op</code>\n"],["inspect","CAS::Op","CAS/Op.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; <code>String</code>\n"],["inspect","CAS::Variable","CAS/Variable.html#method-i-inspect","()","<p>Same as <code>CAS::Op</code>\n"],["invert","CAS","CAS.html#method-c-invert","(x)",""],["list","CAS::Variable","CAS/Variable.html#method-c-list","()","<p>Returns the <code>Hash</code> that contains all the variable\n<p>-&gt; <code>Hash</code>\n"],["ln","CAS","CAS.html#method-c-ln","(x)",""],["log","CAS","CAS.html#method-c-log","(x)",""],["max","CAS","CAS.html#method-c-max","(x, y)",""],["min","CAS","CAS.html#method-c-min","(x, y)",""],["new","Alpha","Alpha.html#method-c-new","(op, var)",""],["new","CAS::BinaryOp","CAS/BinaryOp.html#method-c-new","(x, y)","<p>The binary operator inherits from the <code>CAS::Op</code>, even\nif it is\ndefined as a node with two possible branches. ...\n"],["new","CAS::Condition","CAS/Condition.html#method-c-new","(type, x, y)",""],["new","CAS::Constant","CAS/Constant.html#method-c-new","(x)",""],["new","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-c-new","()",""],["new","CAS::Equal","CAS/Equal.html#method-c-new","(x, y)",""],["new","CAS::Greater","CAS/Greater.html#method-c-new","(x, y)",""],["new","CAS::GreaterEqual","CAS/GreaterEqual.html#method-c-new","(x, y)",""],["new","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-c-new","()",""],["new","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-c-new","()",""],["new","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-c-new","()",""],["new","CAS::Op","CAS/Op.html#method-c-new","(x)","<p>Initialize a new empty operation container. This is a virtual\nclass and the\nother must inherit from this ...\n"],["new","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-c-new","()",""],["new","CAS::Piecewise","CAS/Piecewise.html#method-c-new","(x, y, condition)",""],["new","CAS::Smaller","CAS/Smaller.html#method-c-new","(x, y)",""],["new","CAS::SmallerEqual","CAS/SmallerEqual.html#method-c-new","(x, y)",""],["new","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-c-new","()",""],["new","CAS::Variable","CAS/Variable.html#method-c-new","(name)","<p>Variable is a container for an atomic simbol that becomes a number\nwhen\n<code>CAS::Op#call</code> method is used. ...\n"],["new","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-c-new","()",""],["pow","CAS","CAS.html#method-c-pow","(x, y)",""],["simplify","CAS::Abs","CAS/Abs.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Acos","CAS/Acos.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Asin","CAS/Asin.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Atan","CAS/Atan.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::BinaryOp","CAS/BinaryOp.html#method-i-simplify","()","<p>Executes simplifications of the two branches of the graph\n<p>-&gt; <code>CAS::BinaryOp</code> as <code>self</code>\n"],["simplify","CAS::Condition","CAS/Condition.html#method-i-simplify","()",""],["simplify","CAS::Constant","CAS/Constant.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Cos","CAS/Cos.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Diff","CAS/Diff.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Div","CAS/Div.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Exp","CAS/Exp.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Invert","CAS/Invert.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Ln","CAS/Ln.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Op","CAS/Op.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node\nuntil all\npossible simplification are ...\n"],["simplify","CAS::Pow","CAS/Pow.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Prod","CAS/Prod.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Sin","CAS/Sin.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Sqrt","CAS/Sqrt.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Sum","CAS/Sum.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Tan","CAS/Tan.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["simplify","CAS::Variable","CAS/Variable.html#method-i-simplify","()","<p>Same as <code>CAS::Op</code>\n"],["sin","CAS","CAS.html#method-c-sin","(x)",""],["size","CAS::Variable","CAS/Variable.html#method-c-size","()","<p>Return the number of variable defined\n<p>-&gt; <code>Fixnum</code>\n"],["smaller","CAS","CAS.html#method-c-smaller","(x, y)",""],["smaller","CAS::Op","CAS/Op.html#method-i-smaller","(v)",""],["smaller_equal","CAS","CAS.html#method-c-smaller_equal","(x, y)",""],["smaller_equal","CAS::Op","CAS/Op.html#method-i-smaller_equal","(v)",""],["sqrt","CAS","CAS.html#method-c-sqrt","(x)",""],["subs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs","(dt)","<p>Substituitions for both branches of the graph, same as\n<code>CAS::Op#subs</code>\n<p>&lt;- <code>Hash</code> of substitutions\n-&gt; ...\n"],["subs","CAS::Condition","CAS/Condition.html#method-i-subs","(fd)",""],["subs","CAS::Op","CAS/Op.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n\n<pre>x, y = CAS::vars :x, :y\nf = (x ** 2) + ...</pre>\n"],["tan","CAS","CAS.html#method-c-tan","(x)",""],["to_code","CAS::Abs","CAS/Abs.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Acos","CAS/Acos.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Asin","CAS/Asin.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Atan","CAS/Atan.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_code","()","<p>Code to be used in <code>CAS::BinaryOp#to_proc</code>\n<p>-&gt; <code>String</code>\n"],["to_code","CAS::Condition","CAS/Condition.html#method-i-to_code","()",""],["to_code","CAS::Cos","CAS/Cos.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Diff","CAS/Diff.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Div","CAS/Div.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Exp","CAS/Exp.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Invert","CAS/Invert.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Ln","CAS/Ln.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Op","CAS/Op.html#method-i-to_code","()","<p>Convert expression to code (internal, for <code>CAS::Op#to_proc</code>\nmethod)\n<p>-&gt; <code>String</code> that represent Ruby code …\n"],["to_code","CAS::Piecewise","CAS/Piecewise.html#method-i-to_code","()",""],["to_code","CAS::Pow","CAS/Pow.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Prod","CAS/Prod.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Sin","CAS/Sin.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Sqrt","CAS/Sqrt.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Sum","CAS/Sum.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Tan","CAS/Tan.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_code","CAS::Variable","CAS/Variable.html#method-i-to_code","()","<p>Same as <code>CAS::Op</code>\n"],["to_dot","CAS","CAS.html#method-c-to_dot","(op)","<p>Return a string representation of the graph that is\na Graphviz tree.\nRequires a <code>CAS::Op</code> as argument. ...\n"],["to_s","CAS::Abs","CAS/Abs.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Acos","CAS/Acos.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Asin","CAS/Asin.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Atan","CAS/Atan.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_s","()","<p>String representation of the tree\n<p>-&gt; <code>String</code>\n"],["to_s","CAS::Condition","CAS/Condition.html#method-i-to_s","()",""],["to_s","CAS::Constant","CAS/Constant.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Cos","CAS/Cos.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Diff","CAS/Diff.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Div","CAS/Div.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Exp","CAS/Exp.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Invert","CAS/Invert.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Ln","CAS/Ln.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Op","CAS/Op.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; <code>String</code> to print on screen\n"],["to_s","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Piecewise","CAS/Piecewise.html#method-i-to_s","()",""],["to_s","CAS::Pow","CAS/Pow.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Prod","CAS/Prod.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Sin","CAS/Sin.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Sqrt","CAS/Sqrt.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Sum","CAS/Sum.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Tan","CAS/Tan.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::Variable","CAS/Variable.html#method-i-to_s","()","<p>Same as <code>CAS::Op</code>\n"],["to_s","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-i-to_s","()",""],["vars","CAS","CAS.html#method-c-vars","(*name)",""],["CHANGELOG","","CHANGELOG.html","","<p>Version 0.1.0: The first release of the Gem, complete of all classes.\nVersion 0.1.2: Added `CAS::Op#to_code` …\n"],["README","","README_md.html","","<p>CAS-RB\n<p>Introduction\n<p>An extremely simple graph, that handles only differentiation.\n"],["MatteoRagni.pem","","certs/MatteoRagni_pem.html","","<p>—–BEGIN CERTIFICATE—–\nMIIDXDCCAkSgAwIBAgIBATANBgkqhkiG9w0BAQUFADA6MQ0wCwYDVQQDDARpbmZv\nMRUwEwYKCZImiZPyLGQBGRYFcmFnbmkxEjAQBgoJkiaJk/IsZAEZFgJtZTAeFw0x …\n"],["ragni-cas.gemspec","","ragni-cas_gemspec.html","","<p>#!/usr/bin/env ruby\n<p>changelog = File.expand_path(&#39;CHANGELOG&#39;, File.dirname(__FILE__))\nchangelog …\n"]]}}