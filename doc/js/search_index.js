var search_data = {"index":{"searchIndex":["cas","abs","acos","asin","atan","binaryop","boxcondition","boxconditionclosed","boxconditionlowerclosed","boxconditionopen","boxconditionupperclosed","caserror","condition","constant","cos","diff","div","e_constant","equal","exp","greater","greaterequal","help","infinity_constant","invert","ln","minus_one_constant","neg_infinity_constant","naryop","one_constant","op","pi_constant","piecewise","pow","prod","sin","smaller","smallerequal","sqrt","sum","two_constant","tan","variable","zero_constant","fixnum","float","!=()","!=()","!=()","*()","*()","*()","**()","**()","**()","+()","+()","+()","-()","-()","-()","-@()","/()","/()","/()","==()","==()","==()","==()","==()","==()","==()","==()","==()","==()","==()","abs()","acos()","args()","args()","args()","args()","args()","args()","as_proc()","asin()","assert()","atan()","box()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","call()","const()","cos()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","depend?()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","diff()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","dot_graph()","equal()","equal()","exist?()","exp()","export_dot()","greater()","greater()","greater_equal()","greater_equal()","inspect()","inspect()","inspect()","inspect()","inspect()","inspect()","invert()","limit()","list()","ln()","log()","max()","min()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","overloaded_div()","overloaded_div()","overloaded_minus()","overloaded_minus()","overloaded_mul()","overloaded_mul()","overloaded_plus()","overloaded_plus()","overloaded_pow()","overloaded_pow()","pow()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","simplify()","sin()","size()","smaller()","smaller()","smaller_equal()","smaller_equal()","sqrt()","subs()","subs()","subs()","subs()","subs()","subs()","subs()","tan()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_code()","to_dot()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_latex()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","vars()","readme"],"longSearchIndex":["cas","cas::abs","cas::acos","cas::asin","cas::atan","cas::binaryop","cas::boxcondition","cas::boxconditionclosed","cas::boxconditionlowerclosed","cas::boxconditionopen","cas::boxconditionupperclosed","cas::caserror","cas::condition","cas::constant","cas::cos","cas::diff","cas::div","cas::e_constant","cas::equal","cas::exp","cas::greater","cas::greaterequal","cas::help","cas::infinity_constant","cas::invert","cas::ln","cas::minus_one_constant","cas::neg_infinity_constant","cas::naryop","cas::one_constant","cas::op","cas::pi_constant","cas::piecewise","cas::pow","cas::prod","cas::sin","cas::smaller","cas::smallerequal","cas::sqrt","cas::sum","cas::two_constant","cas::tan","cas::variable","cas::zero_constant","fixnum","float","cas::boxcondition#!=()","cas::condition#!=()","cas::op#!=()","cas::op#*()","fixnum#*()","float#*()","cas::op#**()","fixnum#**()","float#**()","cas::op#+()","fixnum#+()","float#+()","cas::op#-()","fixnum#-()","float#-()","cas::op#-@()","cas::op#/()","fixnum#/()","float#/()","cas::binaryop#==()","cas::boxcondition#==()","cas::condition#==()","cas::constant#==()","cas::diff#==()","cas::naryop#==()","cas::op#==()","cas::piecewise#==()","cas::prod#==()","cas::sum#==()","cas::variable#==()","cas::abs()","cas::acos()","cas::binaryop#args()","cas::condition#args()","cas::constant#args()","cas::naryop#args()","cas::op#args()","cas::variable#args()","cas::op#as_proc()","cas::asin()","cas::help::assert()","cas::atan()","cas::box()","cas::abs#call()","cas::acos#call()","cas::asin#call()","cas::atan#call()","cas::binaryop#call()","cas::constant#call()","cas::cos#call()","cas::diff#call()","cas::div#call()","cas::exp#call()","cas::invert#call()","cas::ln#call()","cas::naryop#call()","cas::op#call()","cas::piecewise#call()","cas::pow#call()","cas::prod#call()","cas::sin#call()","cas::sqrt#call()","cas::sum#call()","cas::tan#call()","cas::variable#call()","cas::const()","cas::cos()","cas::binaryop#depend?()","cas::boxcondition#depend?()","cas::condition#depend?()","cas::constant#depend?()","cas::naryop#depend?()","cas::op#depend?()","cas::variable#depend?()","cas::abs#diff()","cas::acos#diff()","cas::asin#diff()","cas::atan#diff()","cas::binaryop#diff()","cas::boxcondition#diff()","cas::condition#diff()","cas::constant#diff()","cas::cos#diff()","cas::diff#diff()","cas::div#diff()","cas::exp#diff()","cas::invert#diff()","cas::ln#diff()","cas::naryop#diff()","cas::op#diff()","cas::piecewise#diff()","cas::pow#diff()","cas::prod#diff()","cas::sin#diff()","cas::sqrt#diff()","cas::sum#diff()","cas::tan#diff()","cas::variable#diff()","cas::binaryop#dot_graph()","cas::boxcondition#dot_graph()","cas::condition#dot_graph()","cas::constant#dot_graph()","cas::naryop#dot_graph()","cas::op#dot_graph()","cas::piecewise#dot_graph()","cas::variable#dot_graph()","cas::equal()","cas::op#equal()","cas::variable::exist?()","cas::exp()","cas::export_dot()","cas::greater()","cas::op#greater()","cas::greater_equal()","cas::op#greater_equal()","cas::binaryop#inspect()","cas::condition#inspect()","cas::constant#inspect()","cas::naryop#inspect()","cas::op#inspect()","cas::variable#inspect()","cas::invert()","cas::op#limit()","cas::variable::list()","cas::ln()","cas::log()","cas::max()","cas::min()","cas::binaryop::new()","cas::boxcondition::new()","cas::boxconditionclosed::new()","cas::boxconditionlowerclosed::new()","cas::boxconditionopen::new()","cas::boxconditionupperclosed::new()","cas::condition::new()","cas::constant::new()","cas::e_constant::new()","cas::equal::new()","cas::greater::new()","cas::greaterequal::new()","cas::infinity_constant::new()","cas::minus_one_constant::new()","cas::neg_infinity_constant::new()","cas::naryop::new()","cas::one_constant::new()","cas::op::new()","cas::pi_constant::new()","cas::piecewise::new()","cas::smaller::new()","cas::smallerequal::new()","cas::two_constant::new()","cas::variable::new()","cas::zero_constant::new()","fixnum#overloaded_div()","float#overloaded_div()","fixnum#overloaded_minus()","float#overloaded_minus()","fixnum#overloaded_mul()","float#overloaded_mul()","fixnum#overloaded_plus()","float#overloaded_plus()","fixnum#overloaded_pow()","float#overloaded_pow()","cas::pow()","cas::abs#simplify()","cas::acos#simplify()","cas::asin#simplify()","cas::atan#simplify()","cas::binaryop#simplify()","cas::boxcondition#simplify()","cas::condition#simplify()","cas::constant#simplify()","cas::cos#simplify()","cas::diff#simplify()","cas::div#simplify()","cas::exp#simplify()","cas::invert#simplify()","cas::ln#simplify()","cas::naryop#simplify()","cas::op#simplify()","cas::pow#simplify()","cas::prod#simplify()","cas::sin#simplify()","cas::sqrt#simplify()","cas::sum#simplify()","cas::tan#simplify()","cas::variable#simplify()","cas::sin()","cas::variable::size()","cas::smaller()","cas::op#smaller()","cas::smaller_equal()","cas::op#smaller_equal()","cas::sqrt()","cas::binaryop#subs()","cas::boxcondition#subs()","cas::condition#subs()","cas::constant#subs()","cas::naryop#subs()","cas::op#subs()","cas::variable#subs()","cas::tan()","cas::abs#to_code()","cas::acos#to_code()","cas::asin#to_code()","cas::atan#to_code()","cas::binaryop#to_code()","cas::condition#to_code()","cas::cos#to_code()","cas::diff#to_code()","cas::div#to_code()","cas::exp#to_code()","cas::invert#to_code()","cas::ln#to_code()","cas::naryop#to_code()","cas::op#to_code()","cas::piecewise#to_code()","cas::pow#to_code()","cas::prod#to_code()","cas::sin#to_code()","cas::sqrt#to_code()","cas::sum#to_code()","cas::tan#to_code()","cas::variable#to_code()","cas::to_dot()","cas::abs#to_latex()","cas::acos#to_latex()","cas::asin#to_latex()","cas::atan#to_latex()","cas::binaryop#to_latex()","cas::constant#to_latex()","cas::cos#to_latex()","cas::diff#to_latex()","cas::div#to_latex()","cas::e_constant#to_latex()","cas::equal#to_latex()","cas::exp#to_latex()","cas::greater#to_latex()","cas::greaterequal#to_latex()","cas::infinity_constant#to_latex()","cas::invert#to_latex()","cas::ln#to_latex()","cas::neg_infinity_constant#to_latex()","cas::naryop#to_latex()","cas::op#to_latex()","cas::pi_constant#to_latex()","cas::piecewise#to_latex()","cas::pow#to_latex()","cas::prod#to_latex()","cas::sin#to_latex()","cas::smaller#to_latex()","cas::smallerequal#to_latex()","cas::sqrt#to_latex()","cas::sum#to_latex()","cas::tan#to_latex()","cas::variable#to_latex()","cas::abs#to_s()","cas::acos#to_s()","cas::asin#to_s()","cas::atan#to_s()","cas::binaryop#to_s()","cas::condition#to_s()","cas::constant#to_s()","cas::cos#to_s()","cas::diff#to_s()","cas::div#to_s()","cas::e_constant#to_s()","cas::exp#to_s()","cas::infinity_constant#to_s()","cas::invert#to_s()","cas::ln#to_s()","cas::minus_one_constant#to_s()","cas::neg_infinity_constant#to_s()","cas::naryop#to_s()","cas::one_constant#to_s()","cas::op#to_s()","cas::pi_constant#to_s()","cas::piecewise#to_s()","cas::pow#to_s()","cas::prod#to_s()","cas::sin#to_s()","cas::sqrt#to_s()","cas::sum#to_s()","cas::two_constant#to_s()","cas::tan#to_s()","cas::variable#to_s()","cas::zero_constant#to_s()","cas::vars()",""],"info":[["CAS","","CAS.html","",""],["CAS::Abs","","CAS/Abs.html","","\n<pre>  _   _\n /_\\ | |__ ___\n/ _ \\| &#39;_ (_-&lt;</pre>\n<p>/_/ _<em>._</em>/__/\n"],["CAS::Acos","","CAS/Acos.html","","\n<pre>  _\n /_\\  __ ___ ___\n/ _ \\/ _/ _ (_-&lt;</pre>\n<p>/_/ _<em>_/</em>/\n"],["CAS::Asin","","CAS/Asin.html","","\n<pre>  _       _\n /_\\   __(_)_ _\n/ _ \\ (_-&lt; | &#39; \\</pre>\n<p>/_/ _/<em>_/</em>|_||_|\n"],["CAS::Atan","","CAS/Atan.html","","\n<pre>  _  _\n /_\\| |_ __ _ _ _\n/ _ \\  _/ _` | &#39; \\</pre>\n<p>/_/ _<em>_</em>_,_|_||_|\n"],["CAS::BinaryOp","","CAS/BinaryOp.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span> <span class=\"ruby-identifier\">_</span>                     <span class=\"ruby-identifier\">___</span>\n</pre>\n<p>| _ |_)_ _  __ _ _ _ _  _ / _ \\ _ __ | _ \\ | &#39; / _` | &#39;_| || | (_)\n…\n"],["CAS::BoxCondition","","CAS/BoxCondition.html","",""],["CAS::BoxConditionClosed","","CAS/BoxConditionClosed.html","",""],["CAS::BoxConditionLowerClosed","","CAS/BoxConditionLowerClosed.html","",""],["CAS::BoxConditionOpen","","CAS/BoxConditionOpen.html","",""],["CAS::BoxConditionUpperClosed","","CAS/BoxConditionUpperClosed.html","",""],["CAS::CASError","","CAS/CASError.html","",""],["CAS::Condition","","CAS/Condition.html","",""],["CAS::Constant","","CAS/Constant.html","","\n<pre> ___             _            _\n/ __|___ _ _  __| |_ __ _ _ _| |_</pre>\n<p>| (__/ _ \\ &#39; (_-&lt;  _/ _` | &#39; …\n"],["CAS::Cos","","CAS/Cos.html","","\n<pre> ___\n/ __|___ ___</pre>\n<p>| (__/ _ (_-&lt;\n\n<pre>\\___\\___/__/</pre>\n"],["CAS::Diff","","CAS/Diff.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>  <span class=\"ruby-identifier\">_</span>  <span class=\"ruby-identifier\">__</span>  <span class=\"ruby-identifier\">__</span>\n</pre>\n<p>|   (_)/ _|/ _| | |) | |  _|  _/ |<em>_</em>/|_|_| |_| “`\n"],["CAS::Div","","CAS/Div.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>  <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>|   (_)_ __ | |) | \\ V / |<em>_</em>/|_|_/ “`\n"],["CAS::E_CONSTANT","","CAS/E_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>\n</pre>\n<p>| __| | _| |<em>_</em>|\n"],["CAS::Equal","","CAS/Equal.html","",""],["CAS::Exp","","CAS/Exp.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>                            <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>| <em>_|</em> <em>_</em> __  <em>_</em> _ _  <em>_</em> _ _| |_ | _|\\ \\ /\n&#39;_ / _ \\ &#39; / -_) &#39; …\n"],["CAS::Greater","","CAS/Greater.html","",""],["CAS::GreaterEqual","","CAS/GreaterEqual.html","",""],["CAS::Help","","CAS/Help.html","","<p>Support functions are in this separate Helper class\n"],["CAS::INFINITY_CONSTANT","","CAS/INFINITY_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>       <span class=\"ruby-identifier\">__</span> <span class=\"ruby-identifier\">_</span>      <span class=\"ruby-identifier\">_</span> <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>|_ _|_ _  / _(_)_ _ (_) |_ _  _\n\n<pre>| || &#39; \\|  _| | &#39; \\| |  _| || |</pre>\n"],["CAS::Invert","","CAS/Invert.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>                 <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>|_ _|_ <em>_</em> <em>_</em> _ _| |_\n\n<pre>| || &#39; \\ V / -_) &#39;_|  _|</pre>\n"],["CAS::Ln","","CAS/Ln.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_</span>                       <span class=\"ruby-identifier\">_</span> <span class=\"ruby-identifier\">_</span>   <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>| |   <em>_</em>  __ _ __ _ _ _(_) |_| |_  _ __ | |__/ _ / _` / _` |\n&#39;_| | …\n"],["CAS::MINUS_ONE_CONSTANT","","CAS/MINUS_ONE_CONSTANT.html","","\n<pre>    _\n___/ |</pre>\n<p>|<em>_</em>| |\n\n<pre>|_|</pre>\n"],["CAS::NEG_INFINITY_CONSTANT","","CAS/NEG_INFINITY_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_</span>  <span class=\"ruby-identifier\">_</span>          <span class=\"ruby-identifier\">___</span>       <span class=\"ruby-identifier\">__</span> <span class=\"ruby-identifier\">_</span>      <span class=\"ruby-identifier\">_</span> <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>| | |<em>_</em> __ _|_ _|_ _  / _(_)_ _ (_) |_ _  _ | .` / -_) _` || ||\n&#39; …\n"],["CAS::NaryOp","","CAS/NaryOp.html","","<p>This is an attempt to build some sort of node in the graph that has\narbitrary number of childs node. …\n"],["CAS::ONE_CONSTANT","","CAS/ONE_CONSTANT.html","","\n<pre> ___\n/ _ \\ _ _  ___</pre>\n<p>| (_) | &#39; / -_)\n\n<pre>\\___/|_||_\\___|</pre>\n"],["CAS::Op","","CAS/Op.html","","\n<pre> ___\n/ _ \\ _ __</pre>\n<p>| (_) | &#39;_ \\\n\n<pre>\\___/| .__/\n     |_|</pre>\n"],["CAS::PI_CONSTANT","","CAS/PI_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span> <span class=\"ruby-identifier\">___</span>\n</pre>\n<p>| _ _ _| |  _/| | |_| |<em>_</em>|\n"],["CAS::Piecewise","","CAS/Piecewise.html","",""],["CAS::Pow","","CAS/Pow.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>\n</pre>\n<p>| _ _<em>__</em> __ __ |  _/ _ \\ V  V / |_| _<em>_/</em>/_/ “`\n"],["CAS::Prod","","CAS/Prod.html","","<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>             <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>| _ _ _ <em>_</em>  __| | |  _/ &#39;_/ _ / _` | |_| |_| _<em>_/</em>_,_|\n“`\n"],["CAS::Sin","","CAS/Sin.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span> <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>/ <em>_(</em>)_ _ __ \\ | &#39; \\ |<em>_</em>/_|_||_|\n"],["CAS::Smaller","","CAS/Smaller.html","",""],["CAS::SmallerEqual","","CAS/SmallerEqual.html","",""],["CAS::Sqrt","","CAS/Sqrt.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">___</span>           <span class=\"ruby-identifier\">_</span>\n</pre>\n<p>/ __| __ _ _ _| |_ __ / _` | &#39;_|  _| |<em>_</em>/__, |_|  __|\n\n<pre>|_|</pre>\n"],["CAS::Sum","","CAS/Sum.html","","<p>Sum class Sum basic operation. As for now it is implemented as a simple\nbinary operation. It will be …\n"],["CAS::TWO_CONSTANT","","CAS/TWO_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_____</span>\n</pre>\n<p>|_   _|_ __ <em>_</em>\n\n<pre>| | \\ V  V / _ \\\n|_|  \\_/\\_/\\___/</pre>\n"],["CAS::Tan","","CAS/Tan.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_____</span>\n</pre>\n<p>|_   _|_ _ _ _\n\n<pre>| |/ _` | &#39; \\\n|_|\\__,_|_||_|</pre>\n"],["CAS::Variable","","CAS/Variable.html","","<p>__   __        _      _    _ \\ \\ / /_ _ _ _(_)__ _| |__| |<em>_</em>\n\n<pre>\\ V / _` | &#39;_| / _` | &#39;_ \\ / -_)\n \\_/\\__,_|_| ...</pre>\n"],["CAS::ZERO_CONSTANT","","CAS/ZERO_CONSTANT.html","","\n<pre class=\"ruby\"><span class=\"ruby-identifier\">_______</span> <span class=\"ruby-identifier\">___</span>  <span class=\"ruby-identifier\">___</span>\n</pre>\n<p>|_  / __| _ / _ \\\n\n<pre>/ /| _||   / (_) |</pre>\n"],["Fixnum","","Fixnum.html","","\n<pre> ___              _              _ _             _  _                    _\n/ _ \\__ _____ _ _| |___  __ ...</pre>\n"],["Float","","Float.html","",""],["!=","CAS::BoxCondition","CAS/BoxCondition.html#method-i-21-3D","(cond)",""],["!=","CAS::Condition","CAS/Condition.html#method-i-21-3D","(op)",""],["!=","CAS::Op","CAS/Op.html#method-i-21-3D","(op)","<p>Disequality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on …\n"],["*","CAS::Op","CAS/Op.html#method-i-2A","(op)","<p>Returns a product of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["*","Fixnum","Fixnum.html#method-i-2A","(a)",""],["*","Float","Float.html#method-i-2A","(a)",""],["**","CAS::Op","CAS/Op.html#method-i-2A-2A","(op)","<p>Returns the power of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["**","Fixnum","Fixnum.html#method-i-2A-2A","(a)",""],["**","Float","Float.html#method-i-2A-2A","(a)",""],["+","CAS::Op","CAS/Op.html#method-i-2B","(op)","<p>Returns a sum of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["+","Fixnum","Fixnum.html#method-i-2B","(a)",""],["+","Float","Float.html#method-i-2B","(a)",""],["-","CAS::Op","CAS/Op.html#method-i-2D","(op)","<p>Returns a difference of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["-","Fixnum","Fixnum.html#method-i-2D","(a)",""],["-","Float","Float.html#method-i-2D","(a)",""],["-@","CAS::Op","CAS/Op.html#method-i-2D-40","()","<p>Unary operator for inversion of a `CAS::Op`\n<p>-&gt; `CAS::Op` new object\n"],["/","CAS::Op","CAS/Op.html#method-i-2F","(op)","<p>Returns a division of two `CAS::Op`s\n<p>&lt;- `CAS::Op` tree -&gt; `CAS::Op` new object\n"],["/","Fixnum","Fixnum.html#method-i-2F","(a)",""],["/","Float","Float.html#method-i-2F","(a)",""],["==","CAS::BinaryOp","CAS/BinaryOp.html#method-i-3D-3D","(op)","<p>Comparison with other `CAS::Op`. This is *<strong>not</strong>* a math\noperation.\n<p>&lt;- `CAS::Op` to be compared against …\n"],["==","CAS::BoxCondition","CAS/BoxCondition.html#method-i-3D-3D","(cond)",""],["==","CAS::Condition","CAS/Condition.html#method-i-3D-3D","(op)",""],["==","CAS::Constant","CAS/Constant.html#method-i-3D-3D","(op)","<p>Same as `CAS::Op`\n"],["==","CAS::Diff","CAS/Diff.html#method-i-3D-3D","(op)","<p>Same as `CAS::Op`\n"],["==","CAS::NaryOp","CAS/NaryOp.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on the …\n"],["==","CAS::Op","CAS/Op.html#method-i-3D-3D","(op)","<p>Equality operator, the standard operator is overloaded :warning: this\noperates on the graph, not on the …\n"],["==","CAS::Piecewise","CAS/Piecewise.html#method-i-3D-3D","(op)",""],["==","CAS::Prod","CAS/Prod.html#method-i-3D-3D","(op)","<p>Same as `CAS::Op`\n"],["==","CAS::Sum","CAS/Sum.html#method-i-3D-3D","(op)","<p>Same as `CAS::Op`\n"],["==","CAS::Variable","CAS/Variable.html#method-i-3D-3D","(op)","<p>Same as `CAS::Op`\n"],["abs","CAS","CAS.html#method-c-abs","(x)",""],["acos","CAS","CAS.html#method-c-acos","(x)",""],["args","CAS::BinaryOp","CAS/BinaryOp.html#method-i-args","()","<p>Returns an array of all the variables that are in the graph\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::Condition","CAS/Condition.html#method-i-args","()",""],["args","CAS::Constant","CAS/Constant.html#method-i-args","()","<p>Same as `CAS::Op`\n"],["args","CAS::NaryOp","CAS/NaryOp.html#method-i-args","()","<p>Returns a list of all `CAS::Variable`s of the current tree\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::Op","CAS/Op.html#method-i-args","()","<p>Returns a list of all `CAS::Variable`s of the current tree\n<p>-&gt; `Array` of `CAS::Variable`s\n"],["args","CAS::Variable","CAS/Variable.html#method-i-args","()","<p>Same as `CAS::Op`\n"],["as_proc","CAS::Op","CAS/Op.html#method-i-as_proc","(bind=nil)","<p>Evaluates the proc against a given context. It is like having a snapshot of\nthe tree transformed in a …\n"],["asin","CAS","CAS.html#method-c-asin","(x)",""],["assert","CAS::Help","CAS/Help.html#method-c-assert","(obj, type)","<p>Check input `obj.class` against a `type` class raises an ArgumentError if\ncheck fails\n"],["atan","CAS","CAS.html#method-c-atan","(x)",""],["box","CAS","CAS.html#method-c-box","(x, a, b, type=:closed)",""],["call","CAS::Abs","CAS/Abs.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Acos","CAS/Acos.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Asin","CAS/Asin.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Atan","CAS/Atan.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::BinaryOp","CAS/BinaryOp.html#method-i-call","(fd)","<p>Same `CAS::Op#call`\n<p>&lt;- `Hash` of values -&gt; `Numeric` for result\n"],["call","CAS::Constant","CAS/Constant.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Cos","CAS/Cos.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Diff","CAS/Diff.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Div","CAS/Div.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Exp","CAS/Exp.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Invert","CAS/Invert.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Ln","CAS/Ln.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::NaryOp","CAS/NaryOp.html#method-i-call","(fd)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\ndepends upon promotions). As …\n"],["call","CAS::Op","CAS/Op.html#method-i-call","(f)","<p>Call resolves the operation tree in a `Numeric` (if `Fixnum`) or `Float`\ndepends upon promotions). As …\n"],["call","CAS::Piecewise","CAS/Piecewise.html#method-i-call","(fd)",""],["call","CAS::Pow","CAS/Pow.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Prod","CAS/Prod.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Sin","CAS/Sin.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Sqrt","CAS/Sqrt.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Sum","CAS/Sum.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Tan","CAS/Tan.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["call","CAS::Variable","CAS/Variable.html#method-i-call","(f)","<p>Same as `CAS::Op`\n"],["const","CAS","CAS.html#method-c-const","(*val)","<p>Allows to define a series of new constants.\n<p>“` ruby a, b = CAS::const 1.0, 100 “`\n<p>&lt;- `Array` of Numeric …\n"],["cos","CAS","CAS.html#method-c-cos","(x)",""],["depend?","CAS::BinaryOp","CAS/BinaryOp.html#method-i-depend-3F","(v)","<p>Same as `CAS::Op#depend?`\n"],["depend?","CAS::BoxCondition","CAS/BoxCondition.html#method-i-depend-3F","(v)",""],["depend?","CAS::Condition","CAS/Condition.html#method-i-depend-3F","(v)",""],["depend?","CAS::Constant","CAS/Constant.html#method-i-depend-3F","(v)","<p>Same as `CAS::Op`\n"],["depend?","CAS::NaryOp","CAS/NaryOp.html#method-i-depend-3F","(v)","<p>Returns the dependencies of the operation. Require a `CAS::Variable` and it\nis one of the recursive method …\n"],["depend?","CAS::Op","CAS/Op.html#method-i-depend-3F","(v)","<p>Return the dependencies of the operation. Requires a `CAS::Variable` and it\nis one of the recursve method …\n"],["depend?","CAS::Variable","CAS/Variable.html#method-i-depend-3F","(v)","<p>Same as `CAS::Op`\n"],["diff","CAS::Abs","CAS/Abs.html#method-i-diff","(v)","<p>Performs the absolute value of a `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Acos","CAS/Acos.html#method-i-diff","(v)",""],["diff","CAS::Asin","CAS/Asin.html#method-i-diff","(v)",""],["diff","CAS::Atan","CAS/Atan.html#method-i-diff","(v)",""],["diff","CAS::BinaryOp","CAS/BinaryOp.html#method-i-diff","(v)","<p>This method returns an array with the derivatives of the two branches of\nthe node. This method is usually …\n"],["diff","CAS::BoxCondition","CAS/BoxCondition.html#method-i-diff","(v)",""],["diff","CAS::Condition","CAS/Condition.html#method-i-diff","(v)",""],["diff","CAS::Constant","CAS/Constant.html#method-i-diff","(v)","<p>The derivative of a constant is always zero\n"],["diff","CAS::Cos","CAS/Cos.html#method-i-diff","(v)",""],["diff","CAS::Diff","CAS/Diff.html#method-i-diff","(v)","<p>Performs the difference between two `CAS::Op`s\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Div","CAS/Div.html#method-i-diff","(v)","<p>Performs the division between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Exp","CAS/Exp.html#method-i-diff","(v)",""],["diff","CAS::Invert","CAS/Invert.html#method-i-diff","(v)","<p>Performs the inversion of a `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Ln","CAS/Ln.html#method-i-diff","(v)",""],["diff","CAS::NaryOp","CAS/NaryOp.html#method-i-diff","(v)","<p>Return a list of derivative using the chain rule. The input is a operation:\n<p>“`\n\n<pre>f(x) = g(x) + h(x) + l(x) ...</pre>\n"],["diff","CAS::Op","CAS/Op.html#method-i-diff","(v)","<p>Return the derivative of the operation using the chain rule The input is a\n`CAS::Op` because it can handle …\n"],["diff","CAS::Piecewise","CAS/Piecewise.html#method-i-diff","(v)",""],["diff","CAS::Pow","CAS/Pow.html#method-i-diff","(v)","<p>Performs the power between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Prod","CAS/Prod.html#method-i-diff","(v)","<p>Performs the product between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Sin","CAS/Sin.html#method-i-diff","(v)",""],["diff","CAS::Sqrt","CAS/Sqrt.html#method-i-diff","(v)","<p>Performs the square root between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Sum","CAS/Sum.html#method-i-diff","(v)","<p>Performs the sum between two `CAS::Op`\n<p>“`\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">d</span>\n</pre>\n"],["diff","CAS::Tan","CAS/Tan.html#method-i-diff","(v)",""],["diff","CAS::Variable","CAS/Variable.html#method-i-diff","(v)","<p>Returns the derivative of a variable\n<p>“`\n\n<pre>dx      dx\n-- = 1; -- = 0\ndx      dy</pre>\n"],["dot_graph","CAS::BinaryOp","CAS/BinaryOp.html#method-i-dot_graph","(node)","<p>Returns the graphviz representation of the current node\n<p>&lt;- `?` to be removed -&gt; `String`\n"],["dot_graph","CAS::BoxCondition","CAS/BoxCondition.html#method-i-dot_graph","(node)",""],["dot_graph","CAS::Condition","CAS/Condition.html#method-i-dot_graph","(node)",""],["dot_graph","CAS::Constant","CAS/Constant.html#method-i-dot_graph","(node)","<p>Same as `CAS::Op`\n"],["dot_graph","CAS::NaryOp","CAS/NaryOp.html#method-i-dot_graph","(node)","<p>Return the local Graphviz node of the tree\n<p>&lt;- `?` unused variable (TODO: to be removed) -&gt; `String` …\n"],["dot_graph","CAS::Op","CAS/Op.html#method-i-dot_graph","(node)","<p>Return the local Graphviz node of the tree\n<p>&lt;- `?` unused variable (TODO: to be removed) -&gt; `String` …\n"],["dot_graph","CAS::Piecewise","CAS/Piecewise.html#method-i-dot_graph","(node)",""],["dot_graph","CAS::Variable","CAS/Variable.html#method-i-dot_graph","(node)","<p>Same as `CAS::Op`\n"],["equal","CAS","CAS.html#method-c-equal","(x, y)",""],["equal","CAS::Op","CAS/Op.html#method-i-equal","(v)",""],["exist?","CAS::Variable","CAS/Variable.html#method-c-exist-3F","(name)","<p>Returns `true` if a variable already exists\n<p>&lt;- `Object` that represent the variable -&gt; `TrueClass` …\n"],["exp","CAS","CAS.html#method-c-exp","(x)",""],["export_dot","CAS","CAS.html#method-c-export_dot","(fl, op)","<p>Export the input `CAS::Op` graphviz representation to a file. &lt;-\n`String` with filename &lt;- `CAS::Op` …\n"],["greater","CAS","CAS.html#method-c-greater","(x, y)",""],["greater","CAS::Op","CAS/Op.html#method-i-greater","(v)",""],["greater_equal","CAS","CAS.html#method-c-greater_equal","(x, y)",""],["greater_equal","CAS::Op","CAS/Op.html#method-i-greater_equal","(v)",""],["inspect","CAS::BinaryOp","CAS/BinaryOp.html#method-i-inspect","()","<p>Inspector\n<p>-&gt; `String`\n"],["inspect","CAS::Condition","CAS/Condition.html#method-i-inspect","()",""],["inspect","CAS::Constant","CAS/Constant.html#method-i-inspect","()","<p>Same as `CAS::Op`\n"],["inspect","CAS::NaryOp","CAS/NaryOp.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; `String`\n"],["inspect","CAS::Op","CAS/Op.html#method-i-inspect","()","<p>Inspector for the current object\n<p>-&gt; `String`\n"],["inspect","CAS::Variable","CAS/Variable.html#method-i-inspect","()","<p>Same as `CAS::Op`\n"],["invert","CAS","CAS.html#method-c-invert","(x)",""],["limit","CAS::Op","CAS/Op.html#method-i-limit","(a, b, type=:closed)",""],["list","CAS::Variable","CAS/Variable.html#method-c-list","()","<p>Returns the `Hash` that contains all the variable\n<p>-&gt; `Hash`\n"],["ln","CAS","CAS.html#method-c-ln","(x)",""],["log","CAS","CAS.html#method-c-log","(x)",""],["max","CAS","CAS.html#method-c-max","(x, y)",""],["min","CAS","CAS.html#method-c-min","(x, y)",""],["new","CAS::BinaryOp","CAS/BinaryOp.html#method-c-new","(x, y)","<p>The binary operator inherits from the `CAS::Op`, even if it is defined as a\nnode with two possible branches. …\n"],["new","CAS::BoxCondition","CAS/BoxCondition.html#method-c-new","(x, lower, upper, type=:closed)",""],["new","CAS::BoxConditionClosed","CAS/BoxConditionClosed.html#method-c-new","(x, a, b)",""],["new","CAS::BoxConditionLowerClosed","CAS/BoxConditionLowerClosed.html#method-c-new","(x, a, b)",""],["new","CAS::BoxConditionOpen","CAS/BoxConditionOpen.html#method-c-new","(x, a, b)",""],["new","CAS::BoxConditionUpperClosed","CAS/BoxConditionUpperClosed.html#method-c-new","(x, a, b)",""],["new","CAS::Condition","CAS/Condition.html#method-c-new","(type, x, y)",""],["new","CAS::Constant","CAS/Constant.html#method-c-new","(x)",""],["new","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-c-new","()",""],["new","CAS::Equal","CAS/Equal.html#method-c-new","(x, y)",""],["new","CAS::Greater","CAS/Greater.html#method-c-new","(x, y)",""],["new","CAS::GreaterEqual","CAS/GreaterEqual.html#method-c-new","(x, y)",""],["new","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-c-new","()",""],["new","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-c-new","()",""],["new","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-c-new","()",""],["new","CAS::NaryOp","CAS/NaryOp.html#method-c-new","(*xs)","<p>Initialize a new empty N-elements operation container. This is a virtual\nclass, and other must inherit …\n"],["new","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-c-new","()",""],["new","CAS::Op","CAS/Op.html#method-c-new","(x)","<p>Initialize a new empty operation container. This is a virtual class and the\nother must inherit from this …\n"],["new","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-c-new","()",""],["new","CAS::Piecewise","CAS/Piecewise.html#method-c-new","(x, y, condition)",""],["new","CAS::Smaller","CAS/Smaller.html#method-c-new","(x, y)",""],["new","CAS::SmallerEqual","CAS/SmallerEqual.html#method-c-new","(x, y)",""],["new","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-c-new","()",""],["new","CAS::Variable","CAS/Variable.html#method-c-new","(name)","<p>Variable is a container for an atomic simbol that becomes a number when\n`CAS::Op#call` method is used. …\n"],["new","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-c-new","()",""],["overloaded_div","Fixnum","Fixnum.html#method-i-overloaded_div","(a)",""],["overloaded_div","Float","Float.html#method-i-overloaded_div","(a)",""],["overloaded_minus","Fixnum","Fixnum.html#method-i-overloaded_minus","(a)",""],["overloaded_minus","Float","Float.html#method-i-overloaded_minus","(a)",""],["overloaded_mul","Fixnum","Fixnum.html#method-i-overloaded_mul","(a)",""],["overloaded_mul","Float","Float.html#method-i-overloaded_mul","(a)",""],["overloaded_plus","Fixnum","Fixnum.html#method-i-overloaded_plus","(a)",""],["overloaded_plus","Float","Float.html#method-i-overloaded_plus","(a)",""],["overloaded_pow","Fixnum","Fixnum.html#method-i-overloaded_pow","(a)",""],["overloaded_pow","Float","Float.html#method-i-overloaded_pow","(a)",""],["pow","CAS","CAS.html#method-c-pow","(x, y)",""],["simplify","CAS::Abs","CAS/Abs.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Acos","CAS/Acos.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Asin","CAS/Asin.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Atan","CAS/Atan.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::BinaryOp","CAS/BinaryOp.html#method-i-simplify","()","<p>Executes simplifications of the two branches of the graph\n<p>-&gt; `CAS::BinaryOp` as `self`\n"],["simplify","CAS::BoxCondition","CAS/BoxCondition.html#method-i-simplify","()",""],["simplify","CAS::Condition","CAS/Condition.html#method-i-simplify","()",""],["simplify","CAS::Constant","CAS/Constant.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Cos","CAS/Cos.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Diff","CAS/Diff.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Div","CAS/Div.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Exp","CAS/Exp.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Invert","CAS/Invert.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Ln","CAS/Ln.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::NaryOp","CAS/NaryOp.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Op","CAS/Op.html#method-i-simplify","()","<p>Simplification callback. It simplify the subgraph of each node until all\npossible simplification are …\n"],["simplify","CAS::Pow","CAS/Pow.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Prod","CAS/Prod.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Sin","CAS/Sin.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Sqrt","CAS/Sqrt.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Sum","CAS/Sum.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Tan","CAS/Tan.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["simplify","CAS::Variable","CAS/Variable.html#method-i-simplify","()","<p>Same as `CAS::Op`\n"],["sin","CAS","CAS.html#method-c-sin","(x)",""],["size","CAS::Variable","CAS/Variable.html#method-c-size","()","<p>Return the number of variable defined\n<p>-&gt; `Fixnum`\n"],["smaller","CAS","CAS.html#method-c-smaller","(x, y)",""],["smaller","CAS::Op","CAS/Op.html#method-i-smaller","(v)",""],["smaller_equal","CAS","CAS.html#method-c-smaller_equal","(x, y)",""],["smaller_equal","CAS::Op","CAS/Op.html#method-i-smaller_equal","(v)",""],["sqrt","CAS","CAS.html#method-c-sqrt","(x)",""],["subs","CAS::BinaryOp","CAS/BinaryOp.html#method-i-subs","(dt)","<p>Substituitions for both branches of the graph, same as `CAS::Op#subs`\n<p>&lt;- `Hash` of substitutions -&gt; …\n"],["subs","CAS::BoxCondition","CAS/BoxCondition.html#method-i-subs","(fd)",""],["subs","CAS::Condition","CAS/Condition.html#method-i-subs","(fd)",""],["subs","CAS::Constant","CAS/Constant.html#method-i-subs","(dt)","<p>Subs for a constant is a dummy method\n"],["subs","CAS::NaryOp","CAS/NaryOp.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n<p>“` ruby x, y = CAS::vars :x, :y f = (x …\n"],["subs","CAS::Op","CAS/Op.html#method-i-subs","(dt)","<p>Perform substitution of a part of the graph using a data table:\n<p>“` ruby x, y = CAS::vars :x, :y f = (x …\n"],["subs","CAS::Variable","CAS/Variable.html#method-i-subs","(dt)","<p>Terminal substitutions for variables\n"],["tan","CAS","CAS.html#method-c-tan","(x)",""],["to_code","CAS::Abs","CAS/Abs.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Acos","CAS/Acos.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Asin","CAS/Asin.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Atan","CAS/Atan.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_code","()","<p>Code to be used in `CAS::BinaryOp#to_proc`\n<p>-&gt; `String`\n"],["to_code","CAS::Condition","CAS/Condition.html#method-i-to_code","()",""],["to_code","CAS::Cos","CAS/Cos.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Diff","CAS/Diff.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Div","CAS/Div.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Exp","CAS/Exp.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Invert","CAS/Invert.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Ln","CAS/Ln.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::NaryOp","CAS/NaryOp.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Op","CAS/Op.html#method-i-to_code","()","<p>Convert expression to code (internal, for `CAS::Op#to_proc` method)\n<p>-&gt; `String` that represent Ruby …\n"],["to_code","CAS::Piecewise","CAS/Piecewise.html#method-i-to_code","()",""],["to_code","CAS::Pow","CAS/Pow.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Prod","CAS/Prod.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Sin","CAS/Sin.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Sqrt","CAS/Sqrt.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Sum","CAS/Sum.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Tan","CAS/Tan.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_code","CAS::Variable","CAS/Variable.html#method-i-to_code","()","<p>Same as `CAS::Op`\n"],["to_dot","CAS","CAS.html#method-c-to_dot","(op)","<p>Return a string representation of the graph that is a Graphviz tree.\nRequires a `CAS::Op` as argument. …\n"],["to_latex","CAS::Abs","CAS/Abs.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op\n"],["to_latex","CAS::Acos","CAS/Acos.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Asin","CAS/Asin.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Atan","CAS/Atan.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Constant","CAS/Constant.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Cos","CAS/Cos.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Diff","CAS/Diff.html#method-i-to_latex","()","<p>Returns a latex representation of the current Op\n"],["to_latex","CAS::Div","CAS/Div.html#method-i-to_latex","()","<p>Returns the latex reppresentation of the current Op\n"],["to_latex","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_latex","()",""],["to_latex","CAS::Equal","CAS/Equal.html#method-i-to_latex","()",""],["to_latex","CAS::Exp","CAS/Exp.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Greater","CAS/Greater.html#method-i-to_latex","()",""],["to_latex","CAS::GreaterEqual","CAS/GreaterEqual.html#method-i-to_latex","()",""],["to_latex","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_latex","()",""],["to_latex","CAS::Invert","CAS/Invert.html#method-i-to_latex","()","<p>Returns the latex representation of the current op\n"],["to_latex","CAS::Ln","CAS/Ln.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-i-to_latex","()",""],["to_latex","CAS::NaryOp","CAS/NaryOp.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::Op","CAS/Op.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op.\n<p>-&gt; `String`\n"],["to_latex","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_latex","()",""],["to_latex","CAS::Piecewise","CAS/Piecewise.html#method-i-to_latex","()",""],["to_latex","CAS::Pow","CAS/Pow.html#method-i-to_latex","()","<p>Returns the latex representation of the op\n"],["to_latex","CAS::Prod","CAS/Prod.html#method-i-to_latex","()","<p>Returns a latex represstation of the Op\n"],["to_latex","CAS::Sin","CAS/Sin.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Smaller","CAS/Smaller.html#method-i-to_latex","()",""],["to_latex","CAS::SmallerEqual","CAS/SmallerEqual.html#method-i-to_latex","()",""],["to_latex","CAS::Sqrt","CAS/Sqrt.html#method-i-to_latex","()","<p>Returns the latex representation of the current Op\n"],["to_latex","CAS::Sum","CAS/Sum.html#method-i-to_latex","()","<p>Returns a latex represenntation of the current Op\n"],["to_latex","CAS::Tan","CAS/Tan.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_latex","CAS::Variable","CAS/Variable.html#method-i-to_latex","()","<p>Return latex representation of current Op\n"],["to_s","CAS::Abs","CAS/Abs.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Acos","CAS/Acos.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Asin","CAS/Asin.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Atan","CAS/Atan.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::BinaryOp","CAS/BinaryOp.html#method-i-to_s","()","<p>String representation of the tree\n<p>-&gt; `String`\n"],["to_s","CAS::Condition","CAS/Condition.html#method-i-to_s","()",""],["to_s","CAS::Constant","CAS/Constant.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Cos","CAS/Cos.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Diff","CAS/Diff.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Div","CAS/Div.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::E_CONSTANT","CAS/E_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Exp","CAS/Exp.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::INFINITY_CONSTANT","CAS/INFINITY_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Invert","CAS/Invert.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Ln","CAS/Ln.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::MINUS_ONE_CONSTANT","CAS/MINUS_ONE_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::NEG_INFINITY_CONSTANT","CAS/NEG_INFINITY_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::NaryOp","CAS/NaryOp.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::ONE_CONSTANT","CAS/ONE_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Op","CAS/Op.html#method-i-to_s","()","<p>Convert expression to string\n<p>-&gt; `String` to print on screen\n"],["to_s","CAS::PI_CONSTANT","CAS/PI_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Piecewise","CAS/Piecewise.html#method-i-to_s","()",""],["to_s","CAS::Pow","CAS/Pow.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Prod","CAS/Prod.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Sin","CAS/Sin.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Sqrt","CAS/Sqrt.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Sum","CAS/Sum.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::TWO_CONSTANT","CAS/TWO_CONSTANT.html#method-i-to_s","()",""],["to_s","CAS::Tan","CAS/Tan.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::Variable","CAS/Variable.html#method-i-to_s","()","<p>Same as `CAS::Op`\n"],["to_s","CAS::ZERO_CONSTANT","CAS/ZERO_CONSTANT.html#method-i-to_s","()",""],["vars","CAS","CAS.html#method-c-vars","(*name)",""],["README","","README_md.html","","<p>CAS-RB\n<p><img src=\"https://badge.fury.io/rb/ragni-cas.svg\">\n<p>Introduction\n"]]}}